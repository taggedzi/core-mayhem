<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Core Mayhem — 90s Chaos Simulator</title>
<!-- Matter.js (physics) via CDN, no build step -->
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<style>
  :root{
    /* 90s-ish palette */
    --bg:#0b0f1a; /* very dark blue */
    --panel:#0e1730; /* UI panel dark */
    --grid:#123; 
    --scan:rgba(255,255,255,0.03);
    --accent:#ff00aa; /* magenta */
    --teal:#00ffd5;
    --orange:#ff8c1a;
    --blue:#1a9bff;
    --purple:#b86bff;
    --lime:#b6ff00;
    --text:#e6f0ff;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:Verdana, Tahoma, Geneva, sans-serif;}
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
  header{padding:8px 12px; background:linear-gradient(90deg, #0d1942, #13234f); border-bottom:2px solid #20336e; box-shadow:0 2px 0 #0b1126 inset; letter-spacing:0.5px}
  header .brand{font-weight:700; color:var(--teal); text-shadow:0 0 6px #00ffd5aa;} 
  header small{opacity:.8}

  #stage{position:relative; overflow:hidden;}
  canvas{display:block; width:100%; height:100%; image-rendering:pixelated;}
  /* CRT scanline vibe */
  #scanlines{pointer-events:none; position:absolute; inset:0; background-image:
    repeating-linear-gradient(to bottom, rgba(255,255,255,.04) 0, rgba(255,255,255,.04) 1px, transparent 2px, transparent 4px);
    mix-blend-mode:overlay; opacity:.2}

  /* Start panel */
  #panel{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;}
  #panel .card{width:min(880px, 92vw); background:var(--panel); border:2px solid #244; box-shadow:0 0 0 3px #0a122b inset, 0 6px 30px #0009; border-radius:8px; padding:16px 16px 18px}
  .row{display:grid; grid-template-columns:repeat(3,1fr); gap:12px;}
  .row.wide{grid-template-columns:repeat(4,1fr)}
  label{display:block; font-size:12px; opacity:.85; margin-bottom:2px}
  input[type="number"], input[type="text"], select{width:100%; box-sizing:border-box; background:#0a1227; border:1px solid #2b3a78; color:var(--text); padding:6px 8px; border-radius:4px; outline:none}
  input[type="range"]{width:100%}
  .hint{font-size:12px; opacity:.7}
  .btnbar{display:flex; gap:8px; justify-content:flex-end; margin-top:12px}
  button{background:linear-gradient(#19305f, #0f2149); border:1px solid #3558b6; color:#e8f3ff; padding:8px 12px; border-radius:4px; cursor:pointer; font-weight:700; letter-spacing:.4px}
  button:hover{filter:brightness(1.15)}
  button.secondary{background:linear-gradient(#2d1b3f, #221233); border-color:#6a3db6}
  .badge{display:inline-block; padding:2px 6px; font-size:11px; background:#13234f; border:1px solid #2b3a78; border-radius:4px; color:#bfe3ff}

  footer{padding:6px 10px; font-size:12px; color:#bcd; display:flex; gap:10px; align-items:center; justify-content:space-between; border-top:2px solid #20336e; background:#0d1733}
  .dot{display:inline-block; width:8px; height:8px; border-radius:50%; background:var(--lime); box-shadow:0 0 8px var(--lime)}
  #hud{position:absolute; left:8px; bottom:8px; display:flex; gap:10px; align-items:center}
  #hud .chip{background:#0e1730aa; border:1px solid #2b3a78; border-radius:6px; padding:4px 6px; font-size:12px}
  #stopBtn{position:absolute; right:10px; top:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="brand">CORE MAYHEM</span>
    <small> — 90s chaos sim. Watch two machines squabble until one melts.</small>
  </header>
  <div id="stage">
    <canvas id="view"></canvas>
    <div id="scanlines"></div>

    <!-- Start / Settings panel -->
    <div id="panel">
      <div class="card">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px">
          <div>
            <div style="font-weight:800; color:var(--accent); text-shadow:0 0 6px #ff00aa88">Simulation Setup</div>
            <div class="hint">Pick a seed and chaos level, then press <b>Start</b>. After that, it's hands-off.</div>
          </div>
          <div class="badge">Single-file • Browser-only</div>
        </div>

        <div class="row wide" style="margin-top:8px">
          <div>
            <label>Seed (blank = random)</label>
            <input id="seed" type="text" placeholder="e.g. 1337" />
          </div>
          <div>
            <label>Chaos</label>
            <input id="chaos" type="range" min="0" max="1" step="0.01" value="0.7" />
            <div class="hint"><span id="chaosVal">0.70</span></div>
          </div>
          <div>
            <label>Ammo spawn / sec (each side)</label>
            <input id="spawnRate" type="number" min="1" max="120" value="24" />
          </div>
          <div>
            <label>Timescale</label>
            <input id="timescale" type="number" min="0.2" max="2" step="0.1" value="1" />
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <div>
            <label>Target active ammo (each side)</label>
            <input id="maxAmmo" type="number" min="50" max="800" value="260" />
          </div>
          <div>
            <label>Graphics detail</label>
            <select id="gfx">
              <option value="2">High</option>
              <option value="1" selected>Medium</option>
              <option value="0">Low</option>
            </select>
          </div>
          <div>
            <label>Loop same settings when a core dies?</label>
            <select id="loop">
              <option value="1">Yes</option>
              <option value="0" selected>No</option>
            </select>
          </div>
        </div>

        <div class="btnbar">
          <button id="startBtn">▶ Start</button>
          <button id="demoBtn" class="secondary">Surprise me</button>
        </div>

        <div class="hint" style="margin-top:8px; opacity:.75">
          Tips: If things feel heavy, drop spawn rate or set Graphics to Low. The sim targets smoothness on normal desktops.
        </div>
      </div>
    </div>

    <button id="stopBtn" style="display:none">■ Stop / Reset</button>
    <div id="hud" style="display:none">
      <div class="chip"><b>Left Core</b>: <span id="leftHP">—</span></div>
      <div class="chip"><b>Right Core</b>: <span id="rightHP">—</span></div>
      <div class="chip"><b>State</b>: <span id="state">Idle</span></div>
    </div>
  </div>
  <footer>
    <div>Made for modern Firefox/Chrome. Style tribute to the 90s. No trackers, no servers.</div>
    <div><span class="dot" id="fpsDot"></span> <span id="fps">0</span> FPS</div>
  </footer>
</div>

<script>
(function(){
  // ==== Simple Seeded RNG ====
  function RNG(seed){
    let s = (seed>>>0) || (Math.random()*0xFFFFFFFF)>>>0;
    const next = ()=> (s = (s*1664525 + 1013904223)>>>0) / 0x100000000;
    const int = (a,b)=> a + Math.floor(next()*(b-a+1));
    const pick = arr => arr[Math.floor(next()*arr.length)];
    return {next,int,pick,seed:s};
  }

  // ==== DOM ====
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  const panel = document.getElementById('panel');
  const chaosInp = document.getElementById('chaos');
  const chaosVal = document.getElementById('chaosVal');
  const seedInp  = document.getElementById('seed');
  const startBtn = document.getElementById('startBtn');
  const demoBtn  = document.getElementById('demoBtn');
  const loopSel  = document.getElementById('loop');
  const spawnRateInp = document.getElementById('spawnRate');
  const timescaleInp = document.getElementById('timescale');
  const maxAmmoInp = document.getElementById('maxAmmo');
  const gfxSel = document.getElementById('gfx');
  const stopBtn = document.getElementById('stopBtn');
  const hud = document.getElementById('hud');
  const stateSpan = document.getElementById('state');
  const leftHPSpan = document.getElementById('leftHP');
  const rightHPSpan = document.getElementById('rightHP');
  const fpsSpan = document.getElementById('fps');
  const fpsDot  = document.getElementById('fpsDot');

  chaosInp.addEventListener('input', ()=> chaosVal.textContent = Number(chaosInp.value).toFixed(2));

  // ==== Resize ====
  function fit(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', fit);
  fit();

  // ==== Physics setup ====
  const {Engine, World, Bodies, Body, Composite, Composites, Constraint, Runner, Events, Vector} = Matter;
  let engine, runner, world; // created per run

  // Global sim state
  const SIDE = { LEFT:-1, RIGHT:1 };
  let G = null; // current game state
  let lastFpsTime=performance.now(), frames=0, fps=0;

  const PALETTE = {
    bg: getComputedStyle(document.body).getPropertyValue('--bg').trim(),
    left:'#ff8c1a',
    right:'#1a9bff',
    accent:'#ff00aa',
    teal:'#00ffd5',
    purple:'#b86bff',
    lime:'#b6ff00'
  };

  function defaultSettings(){
    return {
      seed: seedInp.value !== '' ? parseInt(seedInp.value,10) : (Math.random()*1e9)|0,
      chaos: Number(chaosInp.value),
      spawnRate: Math.max(1, Number(spawnRateInp.value)),
      timescale: Math.max(0.2, Number(timescaleInp.value)),
      maxAmmo: Math.max(50, Number(maxAmmoInp.value)),
      gfx: Number(gfxSel.value),
      loop: loopSel.value === '1'
    };
  }

  // --- helper: safe segment index from angle ---
  function segIndexFromAngle(core, ang){
    const n = core.segs && core.segs.length ? core.segs.length : 0;
    if (!n) return 0;
    const TAU = Math.PI*2;
    ang = ((ang % TAU) + TAU) % TAU; // normalize to [0, TAU)
    const step = TAU/n;
    const raw = Math.floor(ang/step + 1e-9); // tiny epsilon avoids n on boundary
    const idx = ((raw % n) + n) % n;
    return idx;
  }

  // When a hit lands near the boundary between two slices, split damage.
  // Returns {i0,i1,w0,w1} with w0+w1=1 and indices wrapped.
  function segSplitFromAngle(core, ang){
    const n = core.segs && core.segs.length ? core.segs.length : 0;
    if (!n) return {i0:0,i1:0,w0:1,w1:0};
    const TAU = Math.PI*2; const step = TAU/n;
    ang = ((ang % TAU) + TAU) % TAU;
    const f = ang/step; const base = Math.floor(f);
    const frac = f - base; // 0..1
    const i0 = ((base % n)+n)%n; const i1 = (i0+1)%n;
    const distToBoundary = Math.min(frac, 1-frac);
    const EPS = 0.12; // ~±12% of a slice counts as "between"
    if (distToBoundary < EPS){
      return {i0, i1, w0:0.5, w1:0.5};
    }
    // Otherwise, all damage goes to the nearer segment
    if (frac < 0.5){ return {i0, i1:i0, w0:1, w1:0}; }
    else { return {i0:i1, i1:i1, w0:1, w1:0}; }
  }

  function start(settings){
    // Reset any previous run
    stop();

    // UI states
    panel.style.display='none';
    stopBtn.style.display='block';
    hud.style.display='flex';
    stateSpan.textContent = 'Running';

    // Engine
    engine = Engine.create({ enableSleeping: true });
    world = engine.world;
    engine.gravity.y = 0.9; // general gravity, feels 90s pinball-ish

    runner = Runner.create();
    runner.isFixed = true; // fixed time step for stability
    Runner.run(runner, engine);
    engine.timing.timeScale = settings.timescale;

    const rng = RNG(settings.seed);

    // Dimensions
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // World bounds
    const thickness = 60;
    const walls = [
      Bodies.rectangle(W/2, H+thickness/2, W, thickness, { isStatic:true }),
      Bodies.rectangle(-thickness/2, H/2, thickness, H, { isStatic:true }),
      Bodies.rectangle(W+thickness/2, H/2, thickness, H, { isStatic:true }),
      Bodies.rectangle(W/2, -thickness/2, W, thickness, { isStatic:true })
    ];
    World.add(world, walls);

    // Sloped floors to feed ammo toward outer edges (fixed parenthesis)
    const ramps = [
      Bodies.rectangle(W*0.25, H*0.90, W*0.46, 14, { isStatic:true, angle:-0.07, friction:0.01 }),
      Bodies.rectangle(W*0.75, H*0.90, W*0.46, 14, { isStatic:true, angle: 0.07, friction:0.01 })
    ];
    World.add(world, ramps);

    // Core objects (logic-only bodies for hit detection)
    const coreRadius = Math.min(W, H) * 0.12;
    const coreCenterY = H * 0.66;
    const leftCoreCenter = {x: W*0.28, y: coreCenterY};
    const rightCoreCenter= {x: W*0.72, y: coreCenterY};

    function makeCore(side){
      const center = side===SIDE.LEFT ? leftCoreCenter : rightCoreCenter;
      const color  = side===SIDE.LEFT ? PALETTE.left : PALETTE.right;
      const segments = 12;
      const segHPmax = 26 + Math.floor(10*settings.chaos);
      // Ensure each element is a proper object — no holes
      const segs = Array.from({length:segments}, ()=>({hp:segHPmax}));
      const centerHPmax = 140 + Math.floor(40*settings.chaos);
      const centerBody = Bodies.circle(center.x, center.y, coreRadius*0.34, {isSensor:true, isStatic:true});
      centerBody.plugin = {kind:'coreCenter', side};
      const ringBody = Bodies.circle(center.x, center.y, coreRadius, {isSensor:true, isStatic:true});
      ringBody.plugin = {kind:'coreRing', side};
      World.add(world, [centerBody, ringBody]);
      return {side, color, center, radius:coreRadius, segs, segHPmax, centerHP:centerHPmax, centerHPmax, centerBody, ringBody, shield:0, rot:0, rotSpeed: (rng.next()*0.002 + 0.001) * (rng.next()<0.5?-1:1)};
    }

    const coreL = makeCore(SIDE.LEFT);
    const coreR = makeCore(SIDE.RIGHT);

    // Game end state flags accessible to update & render
    let ended=false; let loopTimer=null; let winMsg='';

    // simple internal tests for segment indexing edge cases
    (function runCoreTests(){
      const testCore = {segs:Array.from({length:12}, ()=>({hp:10}))};
      const TAU = Math.PI*2; let ok=true;
      for(let a=0;a<=12;a++){
        const ang = (a/12)*TAU; const idx = segIndexFromAngle(testCore, ang);
        console.assert(idx>=0 && idx<12, 'segIndex out of range', {ang, idx});
        if(!(idx>=0 && idx<12)) ok=false;
      }
      for(let a=0;a<24;a++){
        const ang = (a/24)*TAU + 0.0001; const s = segSplitFromAngle(testCore, ang);
        const n = testCore.segs.length;
        console.assert(s.i0>=0 && s.i0<n && s.i1>=0 && s.i1<n, 'segSplit idx bad', s);
        console.assert(Math.abs((s.w0+s.w1)-1) < 1e-9, 'weights must sum to 1', s);
      }
      if(ok) console.debug('[tests] segIndexFromAngle & segSplitFromAngle basic checks passed');
    })();

    // Devices & containers per side
    function makeSide(side){
      const sx = side===SIDE.LEFT ? W*0.12 : W*0.88;
      const dir = side===SIDE.LEFT ? 1 : -1; // flow direction toward center
      const color = side===SIDE.LEFT ? PALETTE.left : PALETTE.right;

      // Removed belts & decorative gears per request
      const belts = [];
      const gears = [];

      // Flow pipes: visible paths that tug ammo along segments
      function pathPipe(points, strength, width){
        const segs = [];
        for(let i=0;i<points.length-1;i++){
          const p0 = points[i], p1 = points[i+1];
          const mid = {x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2};
          const dx = p1.x-p0.x, dy = p1.y-p0.y; const len = Math.hypot(dx,dy);
          const ang = Math.atan2(dy,dx);
          const rect = Bodies.rectangle(mid.x, mid.y, Math.max(10,len), width, {isStatic:true, isSensor:true});
          Body.setAngle(rect, ang);
          rect.plugin = {kind:'pipeSeg', dir:{x:dx/len, y:dy/len}, strength, width};
          World.add(world, rect);
          segs.push({body:rect, p0, p1});
        }
        return {points, segs, flow:0, width, strength};
      }

      const edgeX = side===SIDE.LEFT ? 18 : W-18;
      const pipes = [
        pathPipe([
          {x:edgeX, y:H*0.95},
          {x:edgeX, y:H*0.72},
          {x:sx + dir*280, y:H*0.60}
        ], 0.003 + settings.chaos*0.003, 24),
        pathPipe([
          {x:edgeX + dir*30, y:H*0.95},
          {x:edgeX + dir*30, y:H*0.80},
          {x:sx + dir*220, y:H*0.48},
          {x:sx + dir*260, y:H*0.36}
        ], 0.0025 + settings.chaos*0.002, 20)
      ];

      // Containers (bins) — spread vertically on the periphery
      function container(x,y,w,h,accept,cap,label){
        const body = Bodies.rectangle(x,y,w,h, {isStatic:true, isSensor:true});
        body.plugin = {kind:'container', accept};
        World.add(world, body);
        return {body, accept, fill:0, cap, label, pulse:0};
      }

      const bins = {
        cannon: container(edgeX + dir*44, H*0.26, 130, 70, ['basic','heavy','volatile'], 24 + rng.int(0,12), 'CANNON'),
        shield: container(edgeX + dir*50, H*0.52, 118, 64, ['emp','shield'], 16 + rng.int(0,10), 'SHIELD'),
        repair: container(edgeX + dir*50, H*0.82, 118, 64, ['repair'], 14 + rng.int(0,10), 'REPAIR')
      };

      // Toothed pickup gears above bins
      const tooths = [];
      function addTooth(x,y,r,spin){
        const body = Bodies.circle(x,y,r,{isStatic:true, isSensor:true});
        body.plugin = {kind:'tooth', r, spin, angle: Math.random()*Math.PI*2};
        World.add(world, body); tooths.push(body); return body;
      }
      const cb = bins.cannon.body.bounds; addTooth((cb.min.x+cb.max.x)/2 - dir*26, cb.min.y - 14, 18, 0.12*dir);
      const sb = bins.shield.body.bounds; addTooth((sb.min.x+sb.max.x)/2 - dir*22, sb.min.y - 12, 16, 0.10*dir);
      const rb = bins.repair.body.bounds; addTooth((rb.min.x+rb.max.x)/2 - dir*22, rb.min.y - 12, 16, 0.10*dir);

      // Double-sided bulldozer scoops
      function makeDozer(x,y,w,h,range,speed,dirSign){
        const body = Bodies.rectangle(x,y,w,h,{isStatic:true,isSensor:true});
        body.plugin = {kind:'dozer', base:{x,y}, w,h, range, speed, dir:dirSign, t: Math.random()*10, angle:0};
        World.add(world, body); return body;
      }
      const dozers = [
        makeDozer(W*0.50-50, H*0.945, Math.max(200, W*0.26), 18, Math.max(W*0.24, 260), 2.6 + settings.chaos*1.2, -1),
        makeDozer(W*0.50+50, H*0.945, Math.max(200, W*0.26), 18, Math.max(W*0.24, 260), 2.6 + settings.chaos*1.2, +1)
      ];

      const gun = {pos:{x:sx + dir*520, y:H*0.60}, cooldown:0, burst:0, side, color};

      return {side, color, dir, belts, gears, pipes, bins, tooths, dozers, gun, edgeX};
    }

    const left = makeSide(SIDE.LEFT);
    const right= makeSide(SIDE.RIGHT);

    // Ammo spawners (no belts dependency)
    const AMMO_TYPES = ['basic','heavy','volatile','sticky','emp','repair','shield'];
    function spawnAmmo(side){
      const capKey = side===SIDE.LEFT?'leftAmmo':'rightAmmo';
      if (stats[capKey] >= settings.maxAmmo) return;
      const S = side===SIDE.LEFT ? left : right;
      const x = S.edgeX + S.dir*38 + (Math.random()*8-4);
      const y = canvas.clientHeight*0.93 + (Math.random()*6-3);
      const pool = (Math.random()<0.7? ['basic','heavy']: AMMO_TYPES);
      const kind = pool[(Math.random()*pool.length)|0];
      const r = (kind==='heavy'? 8:6);
      const body = Bodies.circle(x,y,r,{ restitution:0.6, friction:0.02, density:0.0015 });
      body.plugin = {kind:'ammo', side, type:kind};
      World.add(world, body);
      Body.setVelocity(body, {x: S.dir*(2 + settings.chaos*3), y: -1});
      stats[capKey]++;
    }

    // Projectiles (from weapons)
    function fireCannon(fromSide, gun, burst){
      if (gun.cooldown>0) return; 
      gun.cooldown = 30; // frames
      gun.burst = burst;
      const target = fromSide===SIDE.LEFT ? coreR.center : coreL.center;
      const dir = Vector.normalise({x:target.x-gun.pos.x, y:target.y-gun.pos.y});
      const speed = 22 + settings.chaos*10;
      for(let i=0;i<burst;i++){
        setTimeout(()=>{
          const b = Bodies.circle(gun.pos.x, gun.pos.y, 4, { restitution:0.2, friction:0.01, density:0.002});
          b.plugin = {kind:'projectile', side:fromSide, dmg: 8 + Math.floor(settings.chaos*6)};
          World.add(world, b);
          Body.setVelocity(b, {x:dir.x*speed + (Math.random()-0.5)*4, y:dir.y*speed + (Math.random()-0.5)*4});
        }, i*40);
      }
    }

    function raiseShield(core, durationMs){
      core.shield = Math.max(core.shield, durationMs/1000); // seconds of shield left
    }

    function repairCore(core, amount){
      for(let n=0;n<amount;n++){
        // pick the weakest segment
        let idx=0, min=Infinity;
        for(let i=0;i<core.segs.length;i++){ const seg=core.segs[i]; if(seg && seg.hp<min){min=seg.hp; idx=i;}}
        const seg = core.segs[idx] || (core.segs[idx] = {hp:0});
        seg.hp = Math.min(core.segHPmax, seg.hp + 8 + Math.floor(settings.chaos*6));
      }
      if (Math.random()<0.25) core.centerHP = Math.min(core.centerHPmax, core.centerHP+6);
    }

    // Containers drain behavior
    function drainLoop(){
      [left,right].forEach(sideObj=>{
        if (sideObj.bins.cannon.fill >= sideObj.bins.cannon.cap){
          sideObj.bins.cannon.fill = 0; sideObj.bins.cannon.pulse=1;
          fireCannon(sideObj.side, sideObj.gun, 18 + Math.floor(Math.random()*6));
        }
        if (sideObj.bins.shield.fill >= sideObj.bins.shield.cap){
          sideObj.bins.shield.fill = 0; sideObj.bins.shield.pulse=1;
          const core = sideObj.side===SIDE.LEFT? coreL:coreR;
          raiseShield(core, 2500 + Math.floor(Math.random()*1500));
        }
        if (sideObj.bins.repair.fill >= sideObj.bins.repair.cap){
          sideObj.bins.repair.fill = 0; sideObj.bins.repair.pulse=1;
          const core = sideObj.side===SIDE.LEFT? coreL:coreR;
          repairCore(core, 3 + Math.floor(Math.random()*2));
        }
        if (sideObj.gun.cooldown>0) sideObj.gun.cooldown--;
      });
    }

    // Collision handling
    Events.on(engine, 'collisionStart', e=>{
      for (const p of e.pairs){
        const A = p.bodyA, B = p.bodyB;
        const a = A.plugin||{}, b = B.plugin||{};

        if (a.kind==='ammo' && b.kind==='container') depositAmmo(A, B);
        else if (b.kind==='ammo' && a.kind==='container') depositAmmo(B, A);

        if (a.kind==='projectile' && (b.kind==='coreRing' || b.kind==='coreCenter')) hitCore(A, B);
        else if (b.kind==='projectile' && (a.kind==='coreRing' || a.kind==='coreCenter')) hitCore(B, A);
      }
    });

    function depositAmmo(ammoBody, containerBody){
      const t = ammoBody.plugin.type;
      const accept = (containerBody.plugin && containerBody.plugin.accept) ? containerBody.plugin.accept : [];
      if (accept.includes(t)){
        World.remove(world, ammoBody);
        if (ammoBody.plugin.side===SIDE.LEFT) stats.leftAmmo--; else stats.rightAmmo--;
        const sideObj = (containerBody.position.x < canvas.clientWidth/2) ? left : right;
        const which = Object.values(sideObj.bins).find(b=>b.body.id === containerBody.id);
        if (which){ which.fill++; which.pulse = 1; }
      }
    }

    function hitCore(projectileBody, coreBody){
      if(!projectileBody || !projectileBody.plugin || projectileBody.plugin.kind!=='projectile' || !coreBody || !coreBody.plugin) return;
      const sideHit = coreBody.plugin.side; 
      const core = sideHit===SIDE.LEFT? coreL:coreR;
      const dmgBase = projectileBody.plugin.dmg || 0;
      const dmg = core.shield>0 ? Math.max(1, Math.floor(dmgBase*0.35)) : dmgBase;

      if (coreBody.plugin.kind==='coreCenter'){
        core.centerHP -= dmg;
      } else {
        const v = Vector.sub(projectileBody.position, core.center);
        let ang = Math.atan2(v.y, v.x) - core.rot;
        const split = segSplitFromAngle(core, ang);
        const d0 = Math.round(dmg * split.w0);
        const d1 = dmg - d0; // remainder to keep integer sums exact
        const s0 = core.segs[split.i0] || (core.segs[split.i0] = {hp:0});
        s0.hp = Math.max(0, s0.hp - d0);
        const s1 = core.segs[split.i1] || (core.segs[split.i1] = {hp:0});
        s1.hp = Math.max(0, s1.hp - d1);
        if (Math.random()<0.08) core.centerHP -= 1;
      }
      World.remove(world, projectileBody);

      if (core.centerHP<=0){
        endMatch(sideHit===SIDE.LEFT? 'RIGHT WINS' : 'LEFT WINS');
      }
    }

    // Track ammo counts
    const stats = { leftAmmo:0, rightAmmo:0 };

    // Per-frame device forces
    Events.on(engine, 'beforeUpdate', ()=>{
      [left,right].forEach(s=>{
        // conveyors (none currently)
        s.belts.forEach(b=>{});

        // toothed pickup gears
        s.tooths.forEach(t=>{
          t.plugin.angle += t.plugin.spin;
          const region = Matter.Query.region(Composite.allBodies(world), t.bounds);
          for(const body of region){
            if (body.plugin && body.plugin.kind==='ammo'){
              const dx = body.position.x - t.position.x; const dy = body.position.y - t.position.y;
              const d = Math.hypot(dx,dy) || 1;
              if (d < (t.circleRadius||18) + 6){
                const nx = dx/d, ny = dy/d; // radial
                const tx = -ny, ty = nx;    // tangential
                Body.applyForce(body, body.position, {x: tx * 0.0028 * body.mass, y: ty * 0.0028 * body.mass});
                Body.applyForce(body, body.position, {x: -nx * 0.0016 * body.mass, y: -ny * 0.0016 * body.mass});
              }
            }
          }
        });

        // dozer scoops motion + launch forces
        s.dozers.forEach(dz=>{
          const dt = (engine.timing.lastDelta||16)/1000;
          dz.plugin.t += dt * dz.plugin.speed;
          const phase = Math.sin(dz.plugin.t);
          const nx = dz.plugin.base.x + phase * dz.plugin.range * dz.plugin.dir;
          Body.setPosition(dz, {x: nx, y: dz.plugin.base.y});
          const ang = 0.08 * phase * dz.plugin.dir; dz.plugin.angle = ang; Body.setAngle(dz, ang);
          const region = Matter.Query.region(Composite.allBodies(world), dz.bounds);
          for(const body of region){
            if (body.plugin && body.plugin.kind==='ammo'){
              Body.applyForce(body, body.position, {x: 0.0035 * body.mass * dz.plugin.dir * Math.sign(phase), y: -0.015*body.mass});
            }
          }
        });

        // pipes suction + centering
        s.pipes.forEach(P=>{
          P.segs.forEach(seg=>{
            const region = Matter.Query.region(Composite.allBodies(world), seg.body.bounds);
            for(const body of region){
              if (body.plugin && body.plugin.kind==='ammo'){
                Body.applyForce(body, body.position, {x: seg.body.plugin.dir.x * seg.body.plugin.strength * body.mass, y: seg.body.plugin.dir.y * seg.body.plugin.strength * body.mass});
                const toward = {x: seg.body.position.x - body.position.x, y: seg.body.position.y - body.position.y};
                const d = Math.hypot(toward.x, toward.y) || 1; toward.x/=d; toward.y/=d;
                Body.applyForce(body, body.position, {x:toward.x*seg.body.plugin.strength*0.4*body.mass, y:toward.y*seg.body.plugin.strength*0.4*body.mass});
              }
            }
          });
        });

        // cosmetic gears (none currently)
        s.gears.forEach(g=>{});
      });

      if (!ended) drainLoop();

      // Maintain target active ammo per side (soft target: ±25%)
      spawnAcc += engine.timing.lastDelta || 16.6667;
      const target = settings.maxAmmo;
      const minTarget = target * 0.75;
      const softMax  = target * 1.25;
      const perSide = settings.spawnRate; // nominal spawns/sec/side
      const msPerSpawn = 1000/perSide;

      function spawnIfNeeded(side, count){
        if (count >= softMax) return;
        if (count < minTarget*0.85){ spawnAmmo(side); spawnAmmo(side); return; }
        if (count < minTarget){ spawnAmmo(side); return; }
        if (count < target){ if (Math.random() < 0.9) spawnAmmo(side); return; }
        if (Math.random() < 0.25) spawnAmmo(side);
      }

      if (!ended){
        while (spawnAcc > msPerSpawn){
          spawnAcc -= msPerSpawn;
          spawnIfNeeded(SIDE.LEFT,  stats.leftAmmo);
          spawnIfNeeded(SIDE.RIGHT, stats.rightAmmo);
        }
      }

      [coreL,coreR].forEach(c=>{ if (c.shield>0) c.shield -= (engine.timing.lastDelta||16)/1000; if(c.shield<0) c.shield=0; c.rot += c.rotSpeed; });

    });

    let spawnAcc = 0;

    // Rendering
    function draw(){
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.fillStyle = PALETTE.bg; ctx.fillRect(0,0,W,H);

      ctx.strokeStyle = '#20336e';
      ctx.lineWidth = 2; ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke(); ctx.setLineDash([]);

      drawFloors();
      drawSide(left); drawSide(right);
      drawDynamic();
      drawCore(coreL); drawCore(coreR);

      leftHPSpan.textContent = `${coreL.centerHP}|Σ${coreL.segs.reduce((s,v)=>s+(v&&v.hp||0),0)}`;
      rightHPSpan.textContent= `${coreR.centerHP}|Σ${coreR.segs.reduce((s,v)=>s+(v&&v.hp||0),0)}`;

      if (ended){
        // full-screen banner overlay
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0,0,W,H);
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = 'bold 64px Verdana';
        const msg = winMsg || 'GAME OVER';
        // color hint by winner
        let col = PALETTE.accent;
        if (/LEFT/.test(msg)) col = PALETTE.left; else if (/RIGHT/.test(msg)) col = PALETTE.right;
        ctx.fillStyle = '#0b1227'; ctx.fillText(msg, W/2+2, H/2+2);
        ctx.fillStyle = col; ctx.shadowColor = col; ctx.shadowBlur = 18; ctx.fillText(msg, W/2, H/2);
        ctx.shadowBlur=0;
        ctx.font = 'bold 18px Verdana'; ctx.fillStyle = '#cfe6ff';
        ctx.fillText('Restarting…', W/2, H/2+54);
        ctx.restore();
      }

      frames++; const now = performance.now();
      if (now-lastFpsTime>500){ fps = Math.round(frames*1000/(now-lastFpsTime)); frames=0; lastFpsTime=now; fpsSpan.textContent=fps; fpsDot.style.background = fps>=50? 'var(--lime)' : fps>=35? '#ffca1a' : '#ff3d3d'; }

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);

    // Stop button
    stopBtn.onclick = ()=>{ endMatch('Canceled'); };

    // End + loop logic
    function endMatch(msg){
      if (ended) return; ended=true; winMsg = msg; stateSpan.textContent = msg; 
      coreL.shield=0; coreR.shield=0;
      if (settings.loop && msg!=='Canceled'){
        setTimeout(()=> start(settings), 2000);
      } else {
        setTimeout(()=>{ panel.style.display='flex'; stopBtn.style.display='none'; hud.style.display='none'; }, 600);
      }
    }

    // expose a bit for debugging if needed
    G = {settings, rng, endMatch};
  }

  function drawCore(core){
    const {x,y} = core.center; const R = core.radius;
    ctx.lineWidth = 8; ctx.strokeStyle = core.color; ctx.globalAlpha = 0.8; 
    ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;

    const n = core.segs.length; const step = Math.PI*2/n;
    for(let i=0;i<n;i++){
      const seg = core.segs[i] || {hp:0};
      const t = seg.hp/core.segHPmax; 
      const a0 = i*step + core.rot - 0.04, a1 = (i+1)*step + core.rot + 0.04;
      ctx.beginPath(); ctx.moveTo(x,y);
      ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath();
      ctx.fillStyle = i%2? '#0e1730' : '#0b1227';
      ctx.fill();
      if (t>0){
        ctx.save(); ctx.globalAlpha = 0.15 + 0.75*t;
        ctx.fillStyle = core.color; ctx.beginPath(); ctx.moveTo(x,y); ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath(); ctx.fill(); ctx.restore();
      } else {
        ctx.save(); ctx.globalAlpha=0.25; ctx.strokeStyle='#234';
        for(let k=0;k<6;k++){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+Math.cos(a0+k*0.2)*R*0.86, y+Math.sin(a0+k*0.2)*R*0.86); ctx.stroke(); }
        ctx.restore();
      }
    }

    ctx.fillStyle = '#091125'; ctx.beginPath(); ctx.arc(x,y,R*0.34,0,Math.PI*2); ctx.fill();
    ctx.lineWidth = 3; ctx.strokeStyle = core.color; ctx.stroke();

    if (core.shield>0){
      const p = Math.min(1, core.shield/2.5);
      ctx.save(); ctx.globalAlpha = 0.12 + 0.2*p; ctx.strokeStyle = '#00ffd5'; ctx.lineWidth = 16; ctx.beginPath(); ctx.arc(x,y,R*1.05,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }

    // DEAD tag when center is gone
    if (core.centerHP<=0){
      ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='bold 22px Verdana';
      ctx.fillStyle = '#0b1227'; ctx.fillText('DEAD', x+2, y- R*0.34 - 10 +2);
      ctx.fillStyle = '#ff3d3d'; ctx.shadowColor='#ff3d3d'; ctx.shadowBlur=12; ctx.fillText('DEAD', x, y- R*0.34 - 10);
      ctx.restore();
    }
  }

  function drawFloors(){
    ctx.save(); ctx.strokeStyle='#2b3a78'; ctx.globalAlpha=.5; ctx.lineWidth=14; ctx.lineCap='round';
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const y = H*0.90; const pad = 40;
    ctx.beginPath(); ctx.moveTo(W/2, y-18); ctx.lineTo(pad, y+12); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2, y-18); ctx.lineTo(W-pad, y+12); ctx.stroke();
    ctx.restore();
  }

  function drawDynamic(){
    if (!world) return;
    const bodies = Composite.allBodies(world);
    for (const b of bodies){
      if (!b.plugin) continue;
      if (b.plugin.kind === 'ammo'){
        const t = b.plugin.type;
        let col = '#b6ff00';
        if (t==='heavy') col = '#ffca1a';
        else if (t==='volatile') col = '#ff3d3d';
        else if (t==='sticky') col = '#b86bff';
        else if (t==='emp') col = '#00ffd5';
        else if (t==='repair') col = '#6bffb8';
        else if (t==='shield') col = '#9fc5ff';
        ctx.beginPath();
        ctx.arc(b.position.x, b.position.y, b.circleRadius||6, 0, Math.PI*2);
        ctx.fillStyle = col; ctx.globalAlpha = 0.85; ctx.fill(); ctx.globalAlpha=1;
        ctx.lineWidth = 1; ctx.strokeStyle = '#0a1227'; ctx.stroke();
      } else if (b.plugin.kind === 'projectile'){
        ctx.beginPath();
        ctx.arc(b.position.x, b.position.y, 3, 0, Math.PI*2);
        ctx.fillStyle = PALETTE.accent; ctx.globalAlpha = 0.9; ctx.fill(); ctx.globalAlpha=1;
      }
    }
  }

  function drawSide(s){
    const color = s.color;
    ctx.strokeStyle = color; ctx.lineWidth = 2;

    // Pipes
    s.pipes.forEach(P=>{
      ctx.save();
      ctx.strokeStyle = color; ctx.lineWidth = P.width; ctx.globalAlpha=.15; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(P.points[0].x, P.points[0].y);
      for(let i=1;i<P.points.length;i++){ ctx.lineTo(P.points[i].x, P.points[i].y); }
      ctx.stroke();
      P.flow = (P.flow||0) + 2; const dash = 14; const gap = 10;
      ctx.setLineDash([dash, gap]); ctx.lineDashOffset = -P.flow;
      ctx.globalAlpha=.6; ctx.lineWidth = Math.max(4, P.width*0.35); ctx.strokeStyle = color; ctx.stroke();
      ctx.setLineDash([]); ctx.restore();
    });

    // Dozer scoops (visual)
    s.dozers.forEach(dz=>{
      ctx.save(); ctx.translate(dz.position.x, dz.position.y); ctx.rotate(dz.plugin.angle||0);
      const w = dz.plugin.w, h = dz.plugin.h;
      ctx.fillStyle = '#0e1730'; ctx.fillRect(-w/2, -h/2, w, h);
      ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.strokeRect(-w/2, -h/2, w, h);
      ctx.beginPath(); ctx.moveTo(-w/2, -h/2); ctx.lineTo(-w/2-14, 0); ctx.lineTo(-w/2, h/2); ctx.closePath();
      ctx.fillStyle = color; ctx.globalAlpha=.25; ctx.fill(); ctx.globalAlpha=1; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2, -h/2); ctx.lineTo(w/2+14, 0); ctx.lineTo(w/2, h/2); ctx.closePath();
      ctx.fillStyle = color; ctx.globalAlpha=.25; ctx.fill(); ctx.globalAlpha=1; ctx.stroke();
      ctx.restore();
    });

    // Bins
    Object.values(s.bins).forEach(bin=>{
      const {min,max} = bin.body.bounds; const x=min.x, y=min.y, w=max.x-min.x, h=max.y-min.y;
      ctx.fillStyle = '#0a1227'; ctx.fillRect(x,y,w,h);
      ctx.strokeStyle = color; ctx.strokeRect(x,y,w,h);
      const t = bin.fill / bin.cap; const m = Math.max(0, Math.min(1,t));
      ctx.fillStyle = color; ctx.globalAlpha = 0.25 + 0.55*m; ctx.fillRect(x+2, y+h-4 - (h-6)*m, w-4, (h-6)*m);
      ctx.globalAlpha=1;
      ctx.fillStyle = '#9fc5ff'; ctx.font='10px Verdana'; ctx.fillText(bin.label, x+6, y+h+12);
      if (bin.pulse>0){ bin.pulse *= 0.92; ctx.save(); ctx.globalAlpha = bin.pulse*0.6; ctx.strokeStyle = PALETTE.accent; ctx.lineWidth = 4; ctx.strokeRect(x-3,y-3,w+6,h+6); ctx.restore(); }
    });

    // Toothed pickup gears
    s.tooths.forEach(t=>{
      ctx.save(); ctx.translate(t.position.x, t.position.y); ctx.rotate(t.plugin.angle||0);
      const R = t.circleRadius||16; ctx.fillStyle='#0e1730';
      ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill(); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
      for(let i=0;i<8;i++){ ctx.beginPath(); const a=i*Math.PI/4; const r1=R, r2=R+6; ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1); ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2); ctx.stroke(); }
      ctx.restore();
    });
  }

  // ======= Stop & UI =======
  function stop(){
    if (runner){ Runner.stop(runner); runner = null; }
    if (engine){
      const all = Composite.allBodies(engine.world);
      for(const b of all) World.remove(engine.world, b);
      engine = null; world = null;
    }
    stateSpan.textContent = 'Idle';
  }

  // ======= Hook up UI =======
  startBtn.onclick = ()=> start(defaultSettings());
  demoBtn.onclick = ()=>{
    seedInp.value = '';
    chaosInp.value = (Math.random()*0.9+0.1).toFixed(2); chaosVal.textContent=chaosInp.value;
    spawnRateInp.value = 16 + Math.floor(Math.random()*24);
    maxAmmoInp.value = 200 + Math.floor(Math.random()*200);
    gfxSel.value = '1';
    loopSel.value = '1';
    timescaleInp.value = '1';
    start(defaultSettings());
  };

})();
</script>
</body>
</html>
