<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Core Mayhem — 90s Chaos Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<style>
  :root{ --bg:#0b0f1a; --panel:#0e1730; --accent:#ff00aa; --teal:#00ffd5; --text:#e6f0ff; --left:#ff8c1a; --right:#1a9bff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Verdana,Tahoma,Geneva,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header{padding:8px 12px;background:linear-gradient(90deg,#0d1942,#13234f);border-bottom:2px solid #20336e}
  header .brand{font-weight:800;color:var(--teal);text-shadow:0 0 6px #00ffd588}
  #stage{position:relative;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  #panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #panel .card{width:min(860px,92vw);background:var(--panel);border:2px solid #244;border-radius:8px;box-shadow:0 0 0 3px #0a122b inset,0 6px 30px #0009;padding:14px}
  label{font-size:12px;opacity:.8;display:block}
  input,select{background:#0a1227;border:1px solid #2b3a78;color:var(--text);padding:6px 8px;border-radius:4px}
  .row{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
  .btnbar{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  button{background:linear-gradient(#19305f,#0f2149);border:1px solid #3558b6;color:#e8f3ff;padding:8px 12px;border-radius:4px;font-weight:700;cursor:pointer}
  button.secondary{background:linear-gradient(#2d1b3f,#221233);border-color:#6a3db6}
  #hud{position:absolute;left:8px;bottom:8px;display:flex;gap:8px}
  .chip{background:#0e1730cc;border:1px solid #2b3a78;border-radius:6px;padding:4px 6px;font-size:12px}
  #stopBtn{position:absolute;right:12px;top:10px}
  footer{padding:6px 10px;font-size:12px;color:#bcd;border-top:2px solid #20336e;background:#0d1733;display:flex;justify-content:space-between}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="brand">CORE MAYHEM</span>
    <small> — 90s chaos sim. Watch two machines squabble until one melts.</small>
  </header>
  <div id="stage">
    <canvas id="view"></canvas>

    <div id="panel">
      <div class="card">
        <div style="font-weight:800;color:var(--accent);text-shadow:0 0 6px #ff00aa88;margin-bottom:6px">Simulation Setup</div>
        <div class="row">
          <div><label>Seed</label><input id="seed" type="text" placeholder="blank = random"/></div>
          <div><label>Chaos</label><input id="chaos" type="range" min="0" max="1" step="0.01" value="0.7"/><div style="font-size:12px;opacity:.75"><span id="chaosVal">0.70</span></div></div>
          <div><label>Ammo spawn/sec (each side)</label><input id="spawnRate" type="number" min="1" max="120" value="26"/></div>
          <div><label>Target active ammo (ea.)</label><input id="maxAmmo" type="number" min="50" max="900" value="300"/></div>
        </div>
        <div class="row" style="margin-top:8px">
          <div><label>Timescale</label><input id="timescale" type="number" min="0.2" max="2" step="0.1" value="1"/></div>
          <div><label>Graphics</label><select id="gfx"><option value="2">High</option><option value="1" selected>Medium</option><option value="0">Low</option></select></div>
          <div><label>Loop on win?</label><select id="loop"><option value="1">Yes</option><option value="0" selected>No</option></select></div>
        </div>
        <div class="btnbar"><button id="startBtn">▶ Start</button><button id="demoBtn" class="secondary">Surprise me</button></div>
        <div style="font-size:12px;opacity:.75;margin-top:4px">Top gel canopy + 4-channel split → lane funnels → pins/rotors → shaker bars → bins. Core hood + flipper recycle stray ammo.</div>
      </div>
    </div>

    <button id="stopBtn" style="display:none">■ Stop / Reset</button>
    <div id="hud" style="display:none">
      <div class="chip"><b>Left Core</b>: <span id="leftHP">—</span></div>
      <div class="chip"><b>Right Core</b>: <span id="rightHP">—</span></div>
      <div class="chip"><b>State</b>: <span id="state">Idle</span></div>
    </div>
  </div>
  <footer>
    <div>Made for modern Firefox/Chrome. No servers.</div>
    <div><span id="fps">0</span> FPS</div>
  </footer>
</div>

<script>
(function(){
  // ===== Seeded RNG =====
  function RNG(seed){ let s=(seed>>>0)||(Math.random()*0xFFFFFFFF)>>>0; const next=()=> (s=(s*1664525+1013904223)>>>0)/0x100000000; const int=(a,b)=> a+Math.floor(next()*(b-a+1)); const pick=arr=>arr[Math.floor(next()*arr.length)]; return {next,int,pick,seed:s}; }

  // ===== DOM =====
  const canvas=document.getElementById('view'); const ctx=canvas.getContext('2d');
  const chaosInp=chaos, chaosValEl=chaosVal; const seedEl=seed; const startBtn=document.getElementById('startBtn'); const demoBtn=document.getElementById('demoBtn');
  const panel=document.getElementById('panel'); const stopBtn=document.getElementById('stopBtn'); const hud=document.getElementById('hud');
  const leftHP=document.getElementById('leftHP'); const rightHP=document.getElementById('rightHP'); const stateEl=document.getElementById('state'); const fpsEl=document.getElementById('fps');
  const spawnRateEl=spawnRate, timescaleEl=timescale, maxAmmoEl=maxAmmo, gfxEl=gfx, loopEl=loop;
  chaosInp.addEventListener('input',()=> chaosValEl.textContent=Number(chaosInp.value).toFixed(2));
  function fit(){ const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1)); const w=canvas.clientWidth,h=canvas.clientHeight; canvas.width=w*dpr; canvas.height=h*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);} fit();

  // restart sim on resize (keeps seed/settings). Debounced.
  let resizeTimer=null, lastSettings=null, isRunning=false;
  window.addEventListener('resize',()=>{ fit(); if(!isRunning) return; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>start(lastSettings),200); });

  const {Engine,World,Bodies,Body,Composite,Runner,Events,Vector,Query,Constraint}=Matter; let engine,world,runner;
  const SIDE={LEFT:-1,RIGHT:1}; const COLORS={left:getComputedStyle(document.documentElement).getPropertyValue('--left').trim(), right:getComputedStyle(document.documentElement).getPropertyValue('--right').trim(), accent:getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()};

  function settingsFromUI(){ return { seed: seedEl.value!==''? parseInt(seedEl.value,10) : (Math.random()*1e9)|0, chaos:Number(chaosInp.value), spawnRate:Math.max(1,Number(spawnRateEl.value)), timescale:Math.max(0.2,Number(timescaleEl.value)), maxAmmo:Math.max(50,Number(maxAmmoEl.value)), gfx:Number(gfxEl.value), loop: loopEl.value==='1' }; }

  // --- slice helpers -----
  function segSplitFromAngle(core, ang){ const n=core.segs.length; const TAU=Math.PI*2; const step=TAU/n; ang=((ang%TAU)+TAU)%TAU; const f=ang/step; const base=Math.floor(f); const frac=f-base; const i0=base%n, i1=(i0+1)%n; const dist=Math.min(frac,1-frac); const EPS=0.12; if(dist<EPS) return {i0,i1,w0:.5,w1:.5}; return frac<.5? {i0,i1:i0,w0:1,w1:0} : {i0:i1,i1:i1,w0:1,w1:0}; }

  // ===== Game start =====
  let ended=false, rng; let left, right, coreL, coreR; let stats; let spawnAcc=0; let drawables=[]; let AMMO_R_BASE=6; // scales with canvas

  function start(preset){ stop(); const S=preset||settingsFromUI(); lastSettings=S; rng=RNG(S.seed); panel.style.display='none'; stopBtn.style.display='block'; hud.style.display='flex'; stateEl.textContent='Running'; isRunning=true;
    engine=Engine.create({enableSleeping:true}); world=engine.world; engine.gravity.y=0.9; runner=Runner.create(); Runner.run(runner,engine); engine.timing.timeScale=S.timescale;
    const W=canvas.clientWidth,H=canvas.clientHeight; AMMO_R_BASE = Math.max(3, Math.min(7, Math.round(Math.min(W,H)*0.006)));
    // walls
    World.add(world,[ Bodies.rectangle(W/2,H+40,W,80,{isStatic:true}), Bodies.rectangle(-40,H/2,80,H,{isStatic:true}), Bodies.rectangle(W+40,H/2,80,H,{isStatic:true}), Bodies.rectangle(W/2,-40,W,80,{isStatic:true}) ]);

    // bottom conveyors pushing OUT to edge pipes
    const convY=H*0.95; const convW=W*0.48; const leftConv=Bodies.rectangle(W*0.25,convY,convW,18,{isStatic:true,isSensor:true}); leftConv.plugin={kind:'conv',dir:-1}; const rightConv=Bodies.rectangle(W*0.75,convY,convW,18,{isStatic:true,isSensor:true}); rightConv.plugin={kind:'conv',dir:+1}; World.add(world,[leftConv,rightConv]);

    // Edge lift pipes
    const pipeTop=H*0.10, pipeBottom=H*0.925, pipeW=Math.max(36, W*0.036);
    function makePipe(side){
      const x = side===SIDE.LEFT? 24 : W-24; // against walls
      const gapBottom = Math.max(60, H*0.08);
      const wallH = (pipeBottom - pipeTop - gapBottom);
      const wallY = pipeTop + wallH/2;
      const wallL = Bodies.rectangle(x-pipeW/2-6, wallY, 12, wallH, {isStatic:true});
      const wallR = Bodies.rectangle(x+pipeW/2+6, wallY, 12, wallH, {isStatic:true});
      World.add(world,[wallL,wallR]);
      const sign = side===SIDE.LEFT? -1 : +1;
      const intake = Bodies.rectangle(x + sign*(pipeW/2+50), pipeBottom-22, 110, 36, {isStatic:true, isSensor:true});
      intake.plugin = {kind:'intake', x, side};
      World.add(world,intake);
      // top deflector
      const defX = side===SIDE.LEFT? x + pipeW*0.7 : x - pipeW*0.7;
      const defAng = side===SIDE.LEFT? 0.6 : -0.6;
      const defl = Bodies.rectangle(defX, pipeTop+14, 90, 12, {isStatic:true, angle:defAng});
      defl.plugin={kind:'deflector', side};
      World.add(world, defl);
      const segs=[];
      for(let y=pipeBottom;y>pipeTop;y-=28){ const seg=Bodies.rectangle(x,y,pipeW,24,{isStatic:true,isSensor:true}); seg.plugin={kind:'lift',side,x,force:0.006}; World.add(world,seg); segs.push(seg);} 
      return {x,segs,intake,wallL,wallR,defl};
    }
    const leftPipe=makePipe(SIDE.LEFT), rightPipe=makePipe(SIDE.RIGHT);

    // Pin fields (with spinner rows)
    function makePins(side){
      const pins=[]; const rotors=[];
      const rows=10;
      const spacingX=Math.max(AMMO_R_BASE*4.2, W*0.022), spacingY=Math.max(AMMO_R_BASE*3.6, H*0.028);
      const startY=pipeTop+40;
      const mid = side===SIDE.LEFT? W*0.18 : W*0.82; const width = W*0.22;
      for(let r=0;r<rows;r++){
        if((r+1)%3===0){
          const cols=Math.max(3, Math.floor(width/(spacingX*1.5)));
          const rotR=Math.max(AMMO_R_BASE*1.6, 10);
          const sides = r%2?3:4;
          for(let c=0;c<cols;c++){
            const x = mid - width/2 + (c+0.5)*(width/cols);
            const y = startY + r*spacingY;
            const rotor=Bodies.polygon(x,y,sides,rotR,{friction:0,frictionStatic:0,frictionAir:0.02,restitution:0.12});
            rotor.plugin={kind:'rotor',spinDir:(Math.random()<0.5?-1:1)};
            const pin=Constraint.create({pointA:{x,y},bodyB:rotor,length:0,stiffness:1});
            World.add(world,[rotor,pin]);
            Body.setAngularVelocity(rotor, rotor.plugin.spinDir*(0.6+Math.random()*0.6));
            rotors.push(rotor);
          }
        } else {
          const cols=Math.max(6, Math.floor(width/spacingX));
          const offset=(r%2?0.5:0)*spacingX;
          const pinR=Math.max(AMMO_R_BASE*0.7,3);
          for(let c=0;c<cols;c++){
            const x = mid - width/2 + c*spacingX + offset;
            const y = startY + r*spacingY;
            World.add(world, Bodies.circle(x,y,pinR,{isStatic:true,restitution:0.9,plugin:{kind:'pin'}}));
          }
        }
      }
      return {mid,width,pins,rotors};
    }
    const pinsL=makePins(SIDE.LEFT), pinsR=makePins(SIDE.RIGHT);

    // ========= Top-canopy & channels & funnels =========
    const gels=[]; // collect gel bodies
    function addGelCurtain(x,y,w,h,opts=0.55){
      const cfg = (typeof opts==='number') ? {k:opts} : (opts||{});
      const g = Bodies.rectangle(x,y,w,h,{isStatic:true,isSensor:true});
      g.plugin = Object.assign({kind:'gel', k:0.55, kx:null, ky:null, forceX:0, forceY:0}, cfg);
      World.add(world,g); gels.push(g); return g;
    }
    function addTopGel(side,pins){
      const w=pins.width*0.96, h=Math.max(AMMO_R_BASE*7,36);
      const y=H*0.14, x=pins.mid;
      return addGelCurtain(x,y,w,h,{kx:0.70, ky:0.20, forceY:0.0018});
    }
    function addChannelSplitter(side,pins){ const shelfY=H*0.16; const shelf=Bodies.rectangle(pins.mid,shelfY,pins.width,10,{isStatic:true}); World.add(world,shelf); const lanes=4, gap=pins.width/lanes; const slats=[]; for(let i=1;i<lanes;i++){ const x=pins.mid - pins.width/2 + i*gap; const slat=Bodies.rectangle(x,shelfY+22,12,60,{isStatic:true}); World.add(world,slat); slats.push(slat);} const tilt=(side===SIDE.LEFT?0.06:-0.06); const overflow=Bodies.rectangle(pins.mid,shelfY+46,pins.width*1.02,8,{isStatic:true,angle:tilt}); World.add(world,overflow); return {shelf,slats,overflow,lanes,gap}; }
    function addMiniFunnel(cx,cy,rOuter,rInner,gapAngle){ const n=Math.max(10, Math.floor(2*Math.PI*rOuter/(AMMO_R_BASE*3))); for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; if(Math.abs(Math.atan2(Math.sin(a),Math.cos(a))) < (gapAngle||0.9)/2) continue; const px=cx+Math.cos(a)*rOuter, py=cy+Math.sin(a)*rOuter; World.add(world,Bodies.circle(px,py,Math.max(AMMO_R_BASE*0.7,3),{isStatic:true,restitution:0.1})); } const slow=Bodies.circle(cx,cy,rOuter*0.9,{isStatic:true,isSensor:true,plugin:{kind:'gel',kx:0.4,ky:0.15}}); World.add(world,slow); gels.push(slow); }
    function addLaneFunnel(cx,baseY,laneW){ const rOuter=Math.max(laneW*0.26, AMMO_R_BASE*4); addMiniFunnel(cx, baseY, rOuter, rOuter*0.45, 0.9); }
    function addShakerRow(pins){ const y=H*0.60; addPaddle(pins.mid - pins.width*0.20, y, 28, 1.2, +1); addPaddle(pins.mid + pins.width*0.20, y, 28, 1.2, -1); }

    addTopGel(SIDE.LEFT,pinsL); const splitL=addChannelSplitter(SIDE.LEFT,pinsL); for(let i=0;i<splitL.lanes;i++){ const cx=pinsL.mid - pinsL.width/2 + splitL.gap*(i+0.5); addLaneFunnel(cx,H*0.28, splitL.gap); }
    addTopGel(SIDE.RIGHT,pinsR); const splitR=addChannelSplitter(SIDE.RIGHT,pinsR); for(let i=0;i<splitR.lanes;i++){ const cx=pinsR.mid - pinsR.width/2 + splitR.gap*(i+0.5); addLaneFunnel(cx,H*0.28, splitR.gap); }

    // ========= Containers (lower) =========
    function makeContainers(side, pinInfo){
      const mid = pinInfo.mid; const width = pinInfo.width;
      const cw = Math.max(56, W*0.035), ch=Math.max(28,H*0.038);
      const xCols = [mid - width*0.36, mid, mid + width*0.36];
      const yRows = [H*0.70, H*0.78];
      const mk=(x,y,label,accept,cap)=>{ const b=Bodies.rectangle(x,y,cw,ch,{isStatic:true,isSensor:true}); b.plugin={kind:'container',accept,label,side}; World.add(world,b); return {body:b,label,accept,fill:0,cap,pulse:0}; };
      return {
        cannon: mk(xCols[0], yRows[0], 'CANNON',['basic','heavy','volatile'], 18+rng.int(0,6)),
        laser:  mk(xCols[1], yRows[0], 'LASER', ['basic','emp'],          14+rng.int(0,6)),
        missile:mk(xCols[2], yRows[0], 'MISSILE',['heavy','volatile'],     12+rng.int(0,6)),
        mortar: mk(xCols[0], yRows[1], 'MORTAR',['basic','heavy'],         16+rng.int(0,6)),
        shield: mk(xCols[1], yRows[1], 'SHIELD',['emp','shield'],          12+rng.int(0,6)),
        repair: mk(xCols[2], yRows[1], 'REPAIR',['repair'],                10+rng.int(0,6))
      };
    }
    left = {side:SIDE.LEFT, color:COLORS.left,  bins:makeContainers(SIDE.LEFT,pinsL)};
    right= {side:SIDE.RIGHT,color:COLORS.right, bins:makeContainers(SIDE.RIGHT,pinsR)};

    // ========= Cores (auto-fit) =========
    function calcCore(side){
      const baseR = Math.min(W,H)*0.15; const gapMid = Math.max(110,W*0.11); const clearance=18;
      if(side===SIDE.LEFT){
        const maxX = Math.max(...Object.values(left.bins).map(b=>b.body.bounds.max.x));
        let cx = Math.min(W/2 - gapMid, W*0.44);
        let R = Math.min(baseR, cx - (maxX + clearance));
        R = Math.max(Math.min(baseR, Math.min(W,H)*0.12), R);
        const cy = H*0.52; return {cx,cy,R,color:COLORS.left,side};
      } else {
        const minX = Math.min(...Object.values(right.bins).map(b=>b.body.bounds.min.x));
        let cx = Math.max(W/2 + gapMid, W*0.56);
        let R = Math.min(baseR, (minX - clearance) - cx);
        R = Math.max(Math.min(baseR, Math.min(W,H)*0.12), R);
        const cy = H*0.52; return {cx,cy,R,color:COLORS.right,side};
      }
    }
    const lc=calcCore(SIDE.LEFT), rc=calcCore(SIDE.RIGHT);

    function makeCore(cfg){ const segs=Array.from({length:12},()=>({hp:44+Math.floor(20*S.chaos)})); const centerHP=190+Math.floor(60*S.chaos); const centerBody=Bodies.circle(cfg.cx,cfg.cy,cfg.R*0.35,{isStatic:true,isSensor:true}); centerBody.plugin={kind:'coreCenter',side: cfg.side}; const ringBody=Bodies.circle(cfg.cx,cfg.cy,cfg.R,{isStatic:true,isSensor:true}); ringBody.plugin={kind:'coreRing',side: cfg.side}; World.add(world,[centerBody,ringBody]); return {center:{x:cfg.cx,y:cfg.cy},radius:cfg.R,segs,segHPmax:segs[0].hp,centerHP:centerHP,centerHPmax:centerHP,centerBody,ringBody,shield:0,rot:0,rotSpeed:(Math.random()*0.002+0.001)*(Math.random()<0.5?-1:1), color: cfg.color}; }
    coreL=makeCore(lc); coreR=makeCore(rc);

    // ========= Core hood + flipper =========
    const flippers=[];
    function addCoreHood(core, side){
      const R=core.radius, x=core.center.x, y=core.center.y;
      const start=-Math.PI*5/6, end=-Math.PI/6; // solid arc over the top
      const segs=11;
      for(let i=0;i<segs;i++){
        const ang = start + (end-start)*(i/(segs-1));
        const px = x + Math.cos(ang)*R*1.04;
        const py = y + Math.sin(ang)*R*1.04;
        const rect = Bodies.rectangle(px, py, R*1.05, 12, { isStatic:true, angle: ang+Math.PI/2, friction:0.01, restitution:0.1, plugin:{kind:'hood'} });
        World.add(world, rect);
      }
      const gel = Bodies.circle(x, y - R*0.8, R*0.7, { isStatic:true, isSensor:true, plugin:{kind:'gel', kx:0.20, ky:0.08, forceY:0.0023} });
      World.add(world, gel); gels.push(gel);
      const tilt = (side===SIDE.LEFT? 0.12 : -0.12);
      const drain = Bodies.rectangle(x, y - R*0.12, R*1.25, 8, { isStatic:true, angle: tilt });
      World.add(world, drain);
    }
    function addFlipper(x, y, length=70, period=4200, kick=0.22){
      const blade = Bodies.rectangle(x, y, length, 10, { friction:0.2, restitution:0.1, plugin:{kind:'flipper',t:(Math.random()*period)|0,period,kick} });
      const pin=Constraint.create({ pointA:{x,y}, bodyB:blade, length:0, stiffness:1 });
      World.add(world,[blade,pin]); flippers.push(blade); return blade;
    }
    addCoreHood(coreL,SIDE.LEFT); addCoreHood(coreR,SIDE.RIGHT);
    addFlipper(coreL.center.x - coreL.radius*0.6, coreL.center.y - coreL.radius*0.2);
    addFlipper(coreR.center.x + coreR.radius*0.6, coreR.center.y - coreR.radius*0.2);

    // Midline anti-clog repulsor for small screens (sensor that nudges balls away from V)
    const repW = Math.max(40, W*0.03), repH = Math.max(60, Math.min(W,H)*0.09);
    const midRep = Bodies.rectangle(W/2, (coreL.center.y+coreR.center.y)/2, repW, repH, {isStatic:true, isSensor:true});
    midRep.plugin={kind:'repulse',strength:0.0025};
    World.add(world, midRep);
    // Hood push sensors
    const hoodPushL = Bodies.rectangle(coreL.center.x, coreL.center.y - coreL.radius*1.0, coreL.radius*1.1, 20, {isStatic:true, isSensor:true}); hoodPushL.plugin={kind:'gel',kx:0.2,ky:0.05,forceY:0.002}; World.add(world, hoodPushL); gels.push(hoodPushL);
    const hoodPushR = Bodies.rectangle(coreR.center.x, coreR.center.y - coreR.radius*1.0, coreR.radius*1.1, 20, {isStatic:true, isSensor:true}); hoodPushR.plugin={kind:'gel',kx:0.2,ky:0.05,forceY:0.002}; World.add(world, hoodPushR); gels.push(hoodPushR);

    // ========= Weapons =========
    function makeWeapons(side){
      const midTopY=H*0.12; const gap = Math.max(110, W*0.11);
      const topMid = (side===SIDE.LEFT? (W/2 - gap*0.6) : (W/2 + gap*0.6));
      const spread=Math.max(32,W*0.03); const sgn = (side===SIDE.RIGHT? -1 : 1);
      const dxs = [-spread, 0, +spread].map(d=> d*sgn); const positions = dxs.map(d=> topMid + d);
      const bottomY=H*0.90; const bottomX = side===SIDE.LEFT? Math.min(W*0.48, W/2 - gap*0.7) : Math.max(W*0.52, W/2 + gap*0.7);
      const color = side===SIDE.LEFT? COLORS.left: COLORS.right;
      return { cannon:{pos:{x:positions[0],y:midTopY},color}, laser:{pos:{x:positions[1],y:midTopY},color}, missile:{pos:{x:positions[2],y:midTopY},color}, mortar:{pos:{x:bottomX,y:bottomY},color} };
    }
    left.weapons = makeWeapons(SIDE.LEFT); right.weapons=makeWeapons(SIDE.RIGHT);

    // ========= Shaker bars (one row) =========
    const paddles=[]; function addPaddle(x,y,amp,spd,dir){ const p=Bodies.rectangle(x,y,80,8,{isStatic:true,isSensor:true}); p.plugin={kind:'paddle',t:Math.random()*6,amp,spd,dir}; World.add(world,p); paddles.push(p);} 
    addShakerRow(pinsL); addShakerRow(pinsR);

    // ===== stats & collisions =====
    stats={leftAmmo:0,rightAmmo:0}; spawnAcc=0; ended=false; drawables=[];

    Events.on(engine,'collisionStart',e=>{ for(const p of e.pairs){ const A=p.bodyA,B=p.bodyB; const a=A.plugin||{}, b=B.plugin||{}; if(a.kind==='ammo'&&b.kind==='container') depositAmmo(A,B); else if(b.kind==='ammo'&&a.kind==='container') depositAmmo(B,A); if(a.kind==='projectile'&&(b.kind==='coreRing'||b.kind==='coreCenter')) hitCore(A,B); else if(b.kind==='projectile'&&(a.kind==='coreRing'||a.kind==='coreCenter')) hitCore(B,A);} });

    // ===== beforeUpdate forces =====
    Events.on(engine,'beforeUpdate',()=>{
      const dt=(engine.timing.lastDelta||16)/1000;
      // conveyors push OUT toward edge pipes
      Composite.allBodies(world).forEach(b=>{ if(!b.plugin||b.plugin.kind!=='ammo') return; if(b.position.y>H*0.915){ const dir= (b.position.x < W/2)? -1 : +1; Body.applyForce(b,b.position,{x: dir*0.002*b.mass, y: -0.001*b.mass}); }});
      // intake + lift
      Composite.allBodies(world).forEach(b=>{ if(!b.plugin||b.plugin.kind!=='ammo') return; [leftPipe,rightPipe].forEach(P=>{ const m=P.intake.bounds; if(b.position.x>m.min.x && b.position.x<m.max.x && b.position.y>m.min.y && b.position.y<m.max.y){ const toward = {x:P.x - b.position.x, y:(H*0.90) - b.position.y}; const d = Math.hypot(toward.x,toward.y)||1; Body.applyForce(b,b.position,{x:(toward.x/d)*0.004*b.mass, y:(toward.y/d)*0.004*b.mass}); } if (b.position.x>P.x-24 && b.position.x<P.x+24 && b.position.y>pipeTop && b.position.y<pipeBottom){ Body.applyForce(b,b.position,{x:0,y:-0.006*b.mass}); } }); });
      // GEL curtains
      gels.forEach(g=>{
        const hits = Query.region(Composite.allBodies(world), g.bounds);
        const kx = (g.plugin.kx!=null ? g.plugin.kx : (g.plugin.k || 0.5));
        const ky = (g.plugin.ky!=null ? g.plugin.ky : ((g.plugin.k || 0.5) * 0.30));
        const bottom = g.bounds.max.y;
        for(const body of hits){
          if(body.plugin && body.plugin.kind==='ammo'){
            let vx = body.velocity.x * (1 - kx*dt);
            let vy = body.velocity.y * (1 - ky*dt);
            if(body.position.y > bottom - 12) vy = Math.max(vy, 36*dt);
            Body.setVelocity(body,{x:vx,y:vy});
            if(g.plugin.forceX || g.plugin.forceY){ Body.applyForce(body, body.position, {x:(g.plugin.forceX||0)*body.mass, y:(g.plugin.forceY||0)*body.mass}); }
          }
        }
      });
      // Keep rotors alive & add tangential shove to nearby ammo
      Composite.allBodies(world).forEach(b=>{ if(!(b.plugin&&b.plugin.kind==='rotor')) return; const minSpin=0.35; if(Math.abs(b.angularVelocity)<minSpin){ Body.setAngularVelocity(b, b.angularVelocity + 0.05*(b.plugin.spinDir||1)); }
        const region={min:{x:b.bounds.min.x-6,y:b.bounds.min.y-6}, max:{x:b.bounds.max.x+6,y:b.bounds.max.y+6}}; const hits=Query.region(Composite.allBodies(world),region); for(const body of hits){ if(body.plugin&&body.plugin.kind==='ammo'){ const dx=body.position.x-b.position.x, dy=body.position.y-b.position.y; const len=Math.hypot(dx,dy)||1; const tx=-dy/len, ty=dx/len; Body.applyForce(body, body.position, {x:tx*0.0009*body.mass, y:ty*0.0009*body.mass}); } } });
      // Shaker paddles
      paddles.forEach(p=>{ p.plugin.t+=dt*p.plugin.spd; const phase=Math.sin(p.plugin.t); const nx=p.position.x + phase*p.plugin.amp*p.plugin.dir; Body.setPosition(p,{x:nx,y:p.position.y}); const region=Query.region(Composite.allBodies(world),p.bounds); for(const body of region){ if(body.plugin&&body.plugin.kind==='ammo'){ Body.applyForce(body,body.position,{x:(phase*0.0022)*body.mass,y:-0.002*body.mass}); } } });
      // Flippers
      flippers.forEach(f=>{ f.plugin.t += engine.timing.lastDelta||16; if(f.plugin.t >= f.plugin.period){ f.plugin.t = 0; Body.setAngularVelocity(f, f.plugin.kick * (Math.random()<0.5?1:-1)); } else { Body.setAngularVelocity(f, f.angularVelocity*0.98); Body.setAngle(f, f.angle*0.98); } });

      // Midline repulsor effect
      Composite.allBodies(world).forEach(b=>{
        if(!(b.plugin && b.plugin.kind==='ammo')) return;
        const pos=b.position;
        if(midRep && pos.x>midRep.bounds.min.x && pos.x<midRep.bounds.max.x && pos.y>midRep.bounds.min.y && pos.y<midRep.bounds.max.y){
          const sign = (pos.x < (W/2)) ? -1 : +1; // push away from midline
          Body.applyForce(b, pos, {x: sign*midRep.plugin.strength*b.mass, y: -0.0005*b.mass});
        }
      });

      // garbage collect stuck ammo & projectiles so supply refills
      const bodies = Composite.allBodies(world);
      bodies.forEach(b=>{
        if(!b.plugin) return;
        if(b.plugin.kind==='ammo'){
          const speed = Math.hypot(b.velocity.x||0,b.velocity.y||0);
          b.plugin.age=(b.plugin.age||0)+dt;
          if(speed<0.15) b.plugin.idle=(b.plugin.idle||0)+dt; else b.plugin.idle=0;
          if(b.position.x<-120||b.position.x>W+120||b.position.y<-120||b.position.y>H+20||(b.plugin.idle||0)>8){
            World.remove(world,b);
            if(b.plugin.side===SIDE.LEFT) stats.leftAmmo--; else stats.rightAmmo--;
          }
        } else if(b.plugin.kind==='projectile'){
          b.plugin.age=(b.plugin.age||0)+dt;
          const speed = Math.hypot(b.velocity.x||0,b.velocity.y||0);
          if(b.position.x<-140||b.position.x>W+140||b.position.y<-140||b.position.y>H+40||b.plugin.age>12|| (b.position.y>H*0.95 && speed<0.05)){
            World.remove(world,b);
          }
        }
      });

      // bins -> actions
      [left,right].forEach(SIDEOBJ=>{ const B=SIDEOBJ.bins; const WPN=SIDEOBJ.weapons; if(B.cannon.fill>=B.cannon.cap){B.cannon.fill=0; fireCannon(SIDEOBJ.side,WPN.cannon,18);} if(B.laser.fill>=B.laser.cap){B.laser.fill=0; fireLaser(SIDEOBJ.side,WPN.laser);} if(B.missile.fill>=B.missile.cap){B.missile.fill=0; fireMissiles(SIDEOBJ.side,WPN.missile,5);} if(B.mortar.fill>=B.mortar.cap){B.mortar.fill=0; fireMortar(SIDEOBJ.side,WPN.mortar);} if(B.shield && B.shield.fill>=B.shield.cap){B.shield.fill=0; (SIDEOBJ.side===SIDE.LEFT?coreL:coreR).shield=Math.max((SIDEOBJ.side===SIDE.LEFT?coreL:coreR).shield,2.5);} if(B.repair && B.repair.fill>=B.repair.cap){B.repair.fill=0; repairCore(SIDEOBJ.side===SIDE.LEFT?coreL:coreR,3);} });

      // soft-target spawning
      spawnAcc += engine.timing.lastDelta||16.6; const target=S.maxAmmo, minT=target*0.75, softMax=target*1.25; const msPer=1000/S.spawnRate;
      while(spawnAcc>msPer){ spawnAcc-=msPer; for(const side of [SIDE.LEFT,SIDE.RIGHT]){ const cnt = side===SIDE.LEFT?stats.leftAmmo:stats.rightAmmo; if(cnt>=softMax) continue; if(cnt<minT*0.85) {spawnAmmo(side); spawnAmmo(side);} else if(cnt<minT) spawnAmmo(side); else if(cnt<target){ if(Math.random()<0.9) spawnAmmo(side);} else { if(Math.random()<0.25) spawnAmmo(side);} } }

      [coreL,coreR].forEach(c=>{ if(c.shield>0)c.shield-=dt; if(c.shield<0)c.shield=0; c.rot+=c.rotSpeed;});
    });

    // ===== render loop =====
    requestAnimationFrame(function draw(){ const W=canvas.clientWidth,H=canvas.clientHeight; AMMO_R_BASE = Math.max(3, Math.min(7, Math.round(Math.min(W,H)*0.006))); ctx.clearRect(0,0,W,H);
      // center line
      ctx.setLineDash([6,6]); ctx.strokeStyle='#20336e'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke(); ctx.setLineDash([]);
      // conveyors
      drawConveyor(W*0.25,convY,convW,18,COLORS.left,-1); drawConveyor(W*0.75,convY,convW,18,COLORS.right,+1);
      // pipes
      drawPipe(leftPipe); drawPipe(rightPipe);
      // gels (visualize)
      ctx.fillStyle='rgba(0,255,213,0.10)';
      gels.forEach(g=>{ if(g.circleRadius){ ctx.beginPath(); ctx.arc(g.position.x,g.position.y,g.circleRadius,0,Math.PI*2); ctx.fill(); } else { const b=g.bounds; ctx.fillRect(b.min.x,b.min.y,b.max.x-b.min.x,b.max.y-b.min.y); } });
      // pins
      ctx.fillStyle='#2b3a78'; Composite.allBodies(world).forEach(b=>{ if(b.plugin&&b.plugin.kind==='pin'){ ctx.beginPath(); ctx.arc(b.position.x,b.position.y,b.circleRadius,0,Math.PI*2); ctx.fill(); }});
      // rotors
      ctx.strokeStyle='#2b3a78'; ctx.lineWidth=2; Composite.allBodies(world).forEach(b=>{ if(b.plugin&&b.plugin.kind==='rotor'){ ctx.beginPath(); const v=b.vertices; ctx.moveTo(v[0].x,v[0].y); for(let i=1;i<v.length;i++){ ctx.lineTo(v[i].x,v[i].y);} ctx.closePath(); ctx.stroke(); }});
      // paddles
      ctx.strokeStyle='#2b3a78'; ctx.lineWidth=8; paddles.forEach(p=>{ ctx.beginPath(); ctx.moveTo(p.bounds.min.x,p.position.y); ctx.lineTo(p.bounds.max.x,p.position.y); ctx.stroke();});
      // flippers
      ctx.strokeStyle='#3558b6'; ctx.lineWidth=6; flippers.forEach(f=>{ ctx.beginPath(); ctx.moveTo(f.bounds.min.x,f.position.y); ctx.lineTo(f.bounds.max.x,f.position.y); ctx.stroke(); });
      // bins
      drawBins(left); drawBins(right);
      // weapons
      drawWeapons(left); drawWeapons(right);
      // bodies
      drawBodies();
      // cores
      drawCore(coreL); drawCore(coreR);
      // beams
      drawables = drawables.filter(d=>{ d.t -= 16; if(d.kind==='beam'){ ctx.save(); ctx.globalAlpha = Math.max(0, d.t/d.T); ctx.strokeStyle=d.color; ctx.lineWidth=5; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke(); ctx.restore(); } return d.t>0; });
      // HUD
      leftHP.textContent=`${coreL.centerHP}|Σ${coreL.segs.reduce((s,v)=>s+Math.max(0,v.hp),0)}`; rightHP.textContent=`${coreR.centerHP}|Σ${coreR.segs.reduce((s,v)=>s+Math.max(0,v.hp),0)}`;
      requestAnimationFrame(draw);
    });

    // ===== drawing helpers =====
    function drawPipe(P){ const Wc=canvas.clientWidth, Hc=canvas.clientHeight; const top=Hc*0.10, bottom=Hc*0.925; const x=P.x; const w=Math.max(36,Wc*0.036); ctx.fillStyle='#0e1730'; ctx.fillRect(x-w/2-12, top-10, 12, (bottom-top)+20); ctx.fillRect(x+w/2, top-10, 12, (bottom-top)+20); const m=P.intake.bounds; ctx.fillStyle='rgba(0,255,213,0.10)'; ctx.fillRect(m.min.x, m.min.y, m.max.x-m.min.x, m.max.y-m.min.y); }
    function drawConveyor(x,y,w,h,color,dir){ ctx.save(); ctx.translate(x-w/2,y-h/2); ctx.fillStyle='rgba(32,52,120,.2)'; ctx.fillRect(0,0,w,h); ctx.strokeStyle=color; ctx.strokeRect(0,0,w,h); const step=22; for(let a=10;a<w-10;a+=step){ ctx.beginPath(); const ax=x-w/2+a; ctx.moveTo(ax, y-6); ctx.lineTo(ax+dir*8,y); ctx.lineTo(ax, y+6); ctx.stroke(); } ctx.restore(); }
    function drawBins(SIDEOBJ){ const color=SIDEOBJ.color; Object.values(SIDEOBJ.bins).forEach(bin=>{ const {min,max}=bin.body.bounds; const x=min.x,y=min.y,w=max.x-min.x,h=max.y-min.y; ctx.fillStyle='#0a1227'; ctx.fillRect(x,y,w,h); ctx.strokeStyle=color; ctx.strokeRect(x,y,w,h); ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+w,y); ctx.lineWidth=3; ctx.strokeStyle='#9fc5ff'; ctx.stroke(); ctx.lineWidth=1; const m=bin.fill/bin.cap; ctx.fillStyle=color; ctx.globalAlpha=.25+.6*Math.min(1,m); ctx.fillRect(x+2,y+h-4-(h-6)*Math.min(1,m),w-4,(h-6)*Math.min(1,m)); ctx.globalAlpha=1; ctx.fillStyle='#cfe6ff'; ctx.font='10px Verdana'; ctx.fillText(bin.label,x+4,y+h+12); }); }
    function drawWeapons(S){ const w=S.weapons; const color=S.color; function icon(pt,shape){ ctx.save(); ctx.translate(pt.x,pt.y); ctx.strokeStyle=color; ctx.lineWidth=2; if(shape==='cannon'){ ctx.strokeRect(-10,-6,20,12); ctx.beginPath(); ctx.moveTo(10,-2); ctx.lineTo(22,0); ctx.lineTo(10,2); ctx.stroke(); } if(shape==='laser'){ ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke(); } if(shape==='missile'){ ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(8,0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(8,0); ctx.lineTo(14,-4); ctx.lineTo(14,4); ctx.closePath(); ctx.stroke(); } if(shape==='mortar'){ ctx.beginPath(); ctx.arc(0,0,10,Math.PI*0.8,Math.PI*1.9); ctx.stroke(); } ctx.restore(); } icon(w.cannon.pos,'cannon'); icon(w.laser.pos,'laser'); icon(w.missile.pos,'missile'); icon(w.mortar.pos,'mortar'); }
    function drawBodies(){ const bodies=Composite.allBodies(world); bodies.forEach(b=>{ if(!b.plugin) return; if(b.plugin.kind==='ammo'){ const t=b.plugin.type; let col='#b6ff00'; if(t==='heavy')col='#ffca1a'; else if(t==='volatile')col='#ff3d3d'; else if(t==='sticky')col='#b86bff'; else if(t==='emp')col='#00ffd5'; else if(t==='repair')col='#6bffb8'; else if(t==='shield')col='#9fc5ff'; ctx.beginPath(); ctx.arc(b.position.x,b.position.y,b.circleRadius||6,0,Math.PI*2); ctx.fillStyle=col; ctx.globalAlpha=.9; ctx.fill(); ctx.globalAlpha=1; ctx.strokeStyle='#0a1227'; ctx.lineWidth=1; ctx.stroke(); } else if(b.plugin.kind==='projectile'){ ctx.beginPath(); ctx.arc(b.position.x,b.position.y,3,0,Math.PI*2); ctx.fillStyle=COLORS.accent; ctx.fill(); } }); }

  // ===== actions =====
  function depositAmmo(ammo, container){ const accept=(container.plugin&&container.plugin.accept)||[]; if(accept.includes(ammo.plugin.type)){ World.remove(world,ammo); (ammo.plugin.side===SIDE.LEFT? stats.leftAmmo--: stats.rightAmmo--); const sideObj = container.plugin.side===SIDE.LEFT? left: right; const which = Object.values(sideObj.bins).find(b=>b.body.id===container.id); if(which){ which.fill++; which.pulse=1; } } }
  function repairCore(core, n){ for(let k=0;k<n;k++){ let idx=0,min=1e9; for(let i=0;i<core.segs.length;i++){ const s=core.segs[i]; if(s.hp<min){min=s.hp; idx=i;}} core.segs[idx].hp=Math.min(core.segHPmax, core.segs[idx].hp + 10);} if(Math.random()<0.25) core.centerHP=Math.min(core.centerHPmax, core.centerHP+6); }
  function hitCore(proj, coreBody){ const sideHit=coreBody.plugin.side; const core= sideHit===SIDE.LEFT? coreL: coreR; const dmgBase=proj.plugin.dmg||0; const dmg = core.shield>0? Math.max(1,Math.floor(dmgBase*0.35)): dmgBase; if(coreBody.plugin.kind==='coreCenter'){ core.centerHP -= dmg;} else { const v=Vector.sub(proj.position, core.center); const ang=Math.atan2(v.y,v.x)-core.rot; const sp=segSplitFromAngle(core,ang); const d0=Math.round(dmg*sp.w0), d1=dmg-d0; core.segs[sp.i0].hp=Math.max(0, core.segs[sp.i0].hp-d0); core.segs[sp.i1].hp=Math.max(0, core.segs[sp.i1].hp-d1); if(Math.random()<0.08) core.centerHP--; } World.remove(world,proj); if(core.centerHP<=0){ endMatch(sideHit===SIDE.LEFT? 'RIGHT WINS':'LEFT WINS'); } }

  function fireCannon(fromSide,w,burst){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; const dir=Vector.normalise({x:target.x-w.pos.x,y:target.y-w.pos.y}); const dist = Math.hypot(target.x - w.pos.x, target.y - w.pos.y); const speed = (22 + Number(chaosInp.value)*10) * Math.min(1.8, Math.max(0.9, dist/600)); for(let i=0;i<burst;i++){ setTimeout(()=>{ const b=Bodies.circle(w.pos.x,w.pos.y,4,{restitution:0.2,friction:0.01,density:0.002}); b.plugin={kind:'projectile',side:fromSide,dmg:8+Math.floor(Number(chaosInp.value)*6)}; World.add(world,b); Body.setVelocity(b,{x:dir.x*speed+(Math.random()-0.5)*4,y:dir.y*speed+(Math.random()-0.5)*4}); drawables.push({kind:'beam',a:{x:w.pos.x,y:w.pos.y},b:{x:w.pos.x+dir.x*24,y:w.pos.y+dir.y*24},color: fromSide===SIDE.LEFT?COLORS.left:COLORS.right,T:120,t:120}); },i*40);} }
  function fireLaser(fromSide,w){ const dps=40; const T=600; const color=fromSide===SIDE.LEFT?COLORS.left:COLORS.right; const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; drawables.push({kind:'beam',a:w.pos,b:target,color,T,t:T}); const core = fromSide===SIDE.LEFT? coreR:coreL; let t=0; const id=setInterval(()=>{ const dt=50; t+=dt; if(core.shield>0){ core.centerHP -= Math.max(1,Math.floor(dps*0.2*dt/1000)); } else { core.centerHP -= Math.floor(dps*dt/1000); } if(t>=T){ clearInterval(id);} if(core.centerHP<=0){ clearInterval(id); endMatch(fromSide===SIDE.LEFT? 'LEFT WINS':'RIGHT WINS'); } },50); }
  function fireMissiles(fromSide,w,count){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; const dist=Math.hypot(target.x-w.pos.x,target.y-w.pos.y); const homeK = Math.min(0.0012, 0.0008 * Math.max(0.8, dist/600)); for(let i=0;i<count;i++){ setTimeout(()=>{ const m=Bodies.circle(w.pos.x,w.pos.y,5,{density:0.003,frictionAir:0.02}); m.plugin={kind:'projectile',type:'missile',side:fromSide,dmg:14,age:0}; World.add(world,m); Body.setVelocity(m,{x:(fromSide===SIDE.LEFT?1:-1)*6+(Math.random()-0.5)*2,y:2}); const id=setInterval(()=>{ if(!world||!m.position) {clearInterval(id);return;} const v={x:target.x-m.position.x,y:target.y-m.position.y}; const d=Math.hypot(v.x,v.y)||1; Body.applyForce(m,m.position,{x:(v.x/d)*homeK*m.mass,y:(v.y/d)*homeK*m.mass}); m.plugin.age=(m.plugin.age||0)+0.03; if(m.plugin.age>10){ clearInterval(id);} },30); },i*100);} }
  function fireMortar(fromSide,w){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; for(let i=0;i<2;i++){ setTimeout(()=>{ const shell=Bodies.circle(w.pos.x,w.pos.y,6,{density:0.004,restitution:0.2}); shell.plugin={kind:'projectile',type:'mortar',side:fromSide,dmg:22}; World.add(world,shell); const vx=(target.x-w.pos.x)/40 + (Math.random()-0.5)*2; const vy=-16 + (Math.random()-0.5)*2; Body.setVelocity(shell,{x:vx,y:vy}); },i*200);} }

  // ===== Spawning
  function spawnAmmo(side){ const W=canvas.clientWidth,H=canvas.clientHeight; const x = side===SIDE.LEFT? 30+Math.random()*40 : W-30-Math.random()*40; const y=H*0.92+Math.random()*10; const AMMO=['basic','heavy','volatile','sticky','emp','repair','shield']; const pool=Math.random()<0.7? ['basic','heavy'] : AMMO; const t=pool[(Math.random()*pool.length)|0]; let r = (t==='heavy'? AMMO_R_BASE+2 : AMMO_R_BASE); r=Math.max(3,Math.min(10,r)); const b=Bodies.circle(x,y,r,{restitution:0.6,friction:0.02,density:0.0015}); b.plugin={kind:'ammo',side,type:t,age:0,idle:0}; World.add(world,b); Body.setVelocity(b,{x: side===SIDE.LEFT? -1:+1, y:-1}); if(side===SIDE.LEFT) stats.leftAmmo++; else stats.rightAmmo++; }

  // ===== End / stop / UI =====
  function endMatch(msg){ if(ended) return; ended=true; stateEl.textContent=msg; setTimeout(()=>{ if(loopEl.value==='1' && msg!=='Canceled'){ start(lastSettings); } else { panel.style.display='flex'; stopBtn.style.display='none'; hud.style.display='none'; isRunning=false; } },2000); }
  function stop(){ if(runner){Runner.stop(runner); runner=null;} if(engine){ const all=Composite.allBodies(engine.world); for(const b of all) World.remove(engine.world,b); engine=null; world=null;} stateEl.textContent='Idle'; }

  // ===== Drawing core =====
  function drawCore(core){ const x=core.center.x,y=core.center.y,R=core.radius; ctx.lineWidth=8; ctx.strokeStyle=core.color; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; const n=core.segs.length, step=Math.PI*2/n; for(let i=0;i<n;i++){ const seg=core.segs[i]; const t=seg.hp/core.segHPmax; const a0=i*step+core.rot-0.04, a1=(i+1)*step+core.rot+0.04; ctx.beginPath(); ctx.moveTo(x,y); ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath(); ctx.fillStyle= i%2? '#0e1730':'#0b1227'; ctx.fill(); if(t>0){ ctx.save(); ctx.globalAlpha=.15 + .75*t; ctx.fillStyle=core.color; ctx.beginPath(); ctx.moveTo(x,y); ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath(); ctx.fill(); ctx.restore(); } else { ctx.save(); ctx.globalAlpha=.25; ctx.strokeStyle='#234'; for(let k=0;k<5;k++){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a0+k*.2)*R*0.86, y+Math.sin(a0+k*.2)*R*0.86); ctx.stroke(); } ctx.restore(); } }
    ctx.fillStyle='#091125'; ctx.beginPath(); ctx.arc(x,y,R*0.34,0,Math.PI*2); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle=core.color; ctx.stroke();
    // visual hood arc
    ctx.save(); ctx.globalAlpha=0.35; ctx.strokeStyle=core.color; ctx.lineWidth=12; ctx.beginPath(); ctx.arc(x,y,R*1.02,-Math.PI*5/6,-Math.PI/6); ctx.stroke(); ctx.restore(); if(core.shield>0){ const p=Math.min(1,core.shield/2.5); ctx.save(); ctx.globalAlpha=.12+.2*p; ctx.strokeStyle:'#00ffd5'; ctx.lineWidth=16; ctx.beginPath(); ctx.arc(x,y,R*1.05,0,Math.PI*2); ctx.stroke(); ctx.restore(); } if(core.centerHP<=0){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='bold 22px Verdana'; ctx.fillStyle='#0b1227'; ctx.fillText('DEAD', x+2, y-R*0.34-10+2); ctx.fillStyle:'#ff3d3d'; ctx.shadowColor:'#ff3d3d'; ctx.shadowBlur=12; ctx.fillText('DEAD', x, y-R*0.34-10); ctx.restore(); } }

  // ===== UI hooks =====
  startBtn.onclick=()=> start(); demoBtn.onclick=()=>{ seedEl.value=''; chaosInp.value=(Math.random()*0.9+0.1).toFixed(2); chaosValEl.textContent=chaosInp.value; spawnRateEl.value= 18+Math.floor(Math.random()*18); maxAmmoEl.value= 220+Math.floor(Math.random()*160); start(); };
  stopBtn.onclick=()=> endMatch('Canceled');
})();
</script>
</body>
</html>
