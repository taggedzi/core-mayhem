<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Core Mayhem — 90s Chaos Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<style>
  :root{ --bg:#0b0f1a; --panel:#0e1730; --accent:#ff00aa; --teal:#00ffd5; --text:#e6f0ff; --left:#ff8c1a; --right:#1a9bff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Verdana,Tahoma,Geneva,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header{padding:8px 12px;background:linear-gradient(90deg,#0d1942,#13234f);border-bottom:2px solid #20336e}
  header .brand{font-weight:800;color:var(--teal);text-shadow:0 0 6px #00ffd588}
  #stage{position:relative;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  #panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #panel .card{width:min(860px,92vw);background:var(--panel);border:2px solid #244;border-radius:8px;box-shadow:0 0 0 3px #0a122b inset,0 6px 30px #0009;padding:14px}
  label{font-size:12px;opacity:.8;display:block}
  input,select{background:#0a1227;border:1px solid #2b3a78;color:var(--text);padding:6px 8px;border-radius:4px}
  .row{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
  .btnbar{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  button{background:linear-gradient(#19305f,#0f2149);border:1px solid #3558b6;color:#e8f3ff;padding:8px 12px;border-radius:4px;font-weight:700;cursor:pointer}
  button.secondary{background:linear-gradient(#2d1b3f,#221233);border-color:#6a3db6}
  #hud{position:absolute;left:8px;bottom:8px;display:flex;gap:8px}
  .chip{background:#0e1730cc;border:1px solid #2b3a78;border-radius:6px;padding:4px 6px;font-size:12px}
  #stopBtn{position:absolute;right:12px;top:10px}
  footer{padding:6px 10px;font-size:12px;color:#bcd;border-top:2px solid #20336e;background:#0d1733;display:flex;justify-content:space-between}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="brand">CORE MAYHEM</span>
    <small> — 90s chaos sim. Watch two machines squabble until one melts.</small>
  </header>
  <div id="stage">
    <canvas id="view"></canvas>

    <div id="panel">
      <div class="card">
        <div style="font-weight:800;color:var(--accent);text-shadow:0 0 6px #ff00aa88;margin-bottom:6px">Simulation Setup</div>
        <div class="row">
          <div><label>Seed</label><input id="seed" type="text" placeholder="blank = random"/></div>
          <div><label>Chaos</label><input id="chaos" type="range" min="0" max="1" step="0.01" value="0.7"/><div style="font-size:12px;opacity:.75"><span id="chaosVal">0.70</span></div></div>
          <div><label>Ammo spawn/sec (each side)</label><input id="spawnRate" type="number" min="1" max="120" value="24"/></div>
          <div><label>Target active ammo (ea.)</label><input id="maxAmmo" type="number" min="50" max="800" value="260"/></div>
        </div>
        <div class="row" style="margin-top:8px">
          <div><label>Timescale</label><input id="timescale" type="number" min="0.2" max="2" step="0.1" value="1"/></div>
          <div><label>Graphics</label><select id="gfx"><option value="2">High</option><option value="1" selected>Medium</option><option value="0">Low</option></select></div>
          <div><label>Loop on win?</label><select id="loop"><option value="1">Yes</option><option value="0" selected>No</option></select></div>
        </div>
        <div class="btnbar"><button id="startBtn">▶ Start</button><button id="demoBtn" class="secondary">Surprise me</button></div>
        <div style="font-size:12px;opacity:.75;margin-top:4px">Layout v3: edge pipes pushed farther out, wider pachinko, staggered bins, cores auto-fit.</div>
      </div>
    </div>

    <button id="stopBtn" style="display:none">■ Stop / Reset</button>
    <div id="hud" style="display:none">
      <div class="chip"><b>Left Core</b>: <span id="leftHP">—</span></div>
      <div class="chip"><b>Right Core</b>: <span id="rightHP">—</span></div>
      <div class="chip"><b>State</b>: <span id="state">Idle</span></div>
    </div>
  </div>
  <footer>
    <div>Made for modern Firefox/Chrome. No servers.</div>
    <div><span id="fps">0</span> FPS</div>
  </footer>
</div>

<script>
(function(){
  // ===== Seeded RNG =====
  function RNG(seed){ let s=(seed>>>0)|| (Math.random()*0xFFFFFFFF)>>>0; const next=()=> (s=(s*1664525+1013904223)>>>0)/0x100000000; const int=(a,b)=> a+Math.floor(next()*(b-a+1)); const pick=arr=>arr[Math.floor(next()*arr.length)]; return {next,int,pick,seed:s}; }

  // ===== DOM =====
  const canvas=document.getElementById('view'); const ctx=canvas.getContext('2d');
  const chaosInp=chaos, chaosValEl=chaosVal; const seedEl=seed; const startBtn=document.getElementById('startBtn'); const demoBtn=document.getElementById('demoBtn');
  const panel=document.getElementById('panel'); const stopBtn=document.getElementById('stopBtn'); const hud=document.getElementById('hud');
  const leftHP=document.getElementById('leftHP'); const rightHP=document.getElementById('rightHP'); const stateEl=document.getElementById('state'); const fpsEl=document.getElementById('fps');
  const spawnRateEl=spawnRate, timescaleEl=timescale, maxAmmoEl=maxAmmo, gfxEl=gfx, loopEl=loop;
  chaosInp.addEventListener('input',()=> chaosValEl.textContent=Number(chaosInp.value).toFixed(2));
  function fit(){ const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1)); const w=canvas.clientWidth,h=canvas.clientHeight; canvas.width=w*dpr; canvas.height=h*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);} fit();

  // restart sim on resize (keeps seed/settings). Debounced.
  let resizeTimer=null, lastSettings=null, isRunning=false;
  window.addEventListener('resize',()=>{ fit(); if(!isRunning) return; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>start(lastSettings),200); });

  const {Engine,World,Bodies,Body,Composite,Runner,Events,Vector,Query,Constraint}=Matter; let engine,world,runner;
  const SIDE={LEFT:-1,RIGHT:1}; const COLORS={left:getComputedStyle(document.documentElement).getPropertyValue('--left').trim(), right:getComputedStyle(document.documentElement).getPropertyValue('--right').trim(), accent:getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()};

  function settingsFromUI(){ return { seed: seedEl.value!==''? parseInt(seedEl.value,10) : (Math.random()*1e9)|0, chaos:Number(chaosInp.value), spawnRate:Math.max(1,Number(spawnRateEl.value)), timescale:Math.max(0.2,Number(timescaleEl.value)), maxAmmo:Math.max(50,Number(maxAmmoEl.value)), gfx:Number(gfxEl.value), loop: loopEl.value==='1' }; }

  // --- slice helpers -----
  function segSplitFromAngle(core, ang){ const n=core.segs.length; const TAU=Math.PI*2; const step=TAU/n; ang=((ang%TAU)+TAU)%TAU; const f=ang/step; const base=Math.floor(f); const frac=f-base; const i0=base%n, i1=(i0+1)%n; const dist=Math.min(frac,1-frac); const EPS=0.12; if(dist<EPS) return {i0,i1,w0:.5,w1:.5}; return frac<.5? {i0,i1:i0,w0:1,w1:0} : {i0:i1,i1:i1,w0:1,w1:0}; }

  // ===== Game start =====
  let ended=false, rng; let left, right, coreL, coreR; let stats; let spawnAcc=0; let drawables=[]; let AMMO_R_BASE=6; // scales with canvas

  function start(preset){ stop(); const S=preset||settingsFromUI(); lastSettings=S; rng=RNG(S.seed); panel.style.display='none'; stopBtn.style.display='block'; hud.style.display='flex'; stateEl.textContent='Running'; isRunning=true;
    engine=Engine.create({enableSleeping:true}); world=engine.world; engine.gravity.y=0.9; runner=Runner.create(); Runner.run(runner,engine); engine.timing.timeScale=S.timescale;
    const W=canvas.clientWidth,H=canvas.clientHeight; AMMO_R_BASE = Math.max(3, Math.min(7, Math.round(Math.min(W,H)*0.006)));
    // walls
    World.add(world,[ Bodies.rectangle(W/2,H+40,W,80,{isStatic:true}), Bodies.rectangle(-40,H/2,80,H,{isStatic:true}), Bodies.rectangle(W+40,H/2,80,H,{isStatic:true}), Bodies.rectangle(W/2,-40,W,80,{isStatic:true}) ]);

    // bottom conveyors pushing OUT to edge pipes
    const convY=H*0.95; const convW=W*0.48; const leftConv=Bodies.rectangle(W*0.25,convY,convW,18,{isStatic:true,isSensor:true}); leftConv.plugin={kind:'conv',dir:-1}; const rightConv=Bodies.rectangle(W*0.75,convY,convW,18,{isStatic:true,isSensor:true}); rightConv.plugin={kind:'conv',dir:+1}; World.add(world,[leftConv,rightConv]);

    // Edge lift pipes per side (move farther to edges)
    const pipeTop=H*0.10, pipeBottom=H*0.925, pipeW=Math.max(36, W*0.036);
    function makePipe(side){
      // stick the pipe hard against the outer wall
      const x = side===SIDE.LEFT? 24 : W-24;
      const gapBottom = Math.max(60, H*0.08); // intake gap at bottom
      const wallH = (pipeBottom - pipeTop - gapBottom);
      const wallY = pipeTop + wallH/2;
      const wallL = Bodies.rectangle(x-pipeW/2-6, wallY, 12, wallH, {isStatic:true});
      const wallR = Bodies.rectangle(x+pipeW/2+6, wallY, 12, wallH, {isStatic:true});
      World.add(world,[wallL,wallR]);
      // intake helper region
      const sign = side===SIDE.LEFT? -1 : +1;
      const intake = Bodies.rectangle(x + sign*(pipeW/2+50), pipeBottom-22, 110, 36, {isStatic:true, isSensor:true});
      intake.plugin = {kind:'intake', x, side};
      World.add(world,intake);
      // angled deflector at the top to bounce inward toward pins
      const defX = side===SIDE.LEFT? x + pipeW*0.7 : x - pipeW*0.7;
      const defAng = side===SIDE.LEFT? 0.6 : -0.6; // ~34°
      const defl = Bodies.rectangle(defX, pipeTop+14, 90, 12, {isStatic:true, angle:defAng});
      defl.plugin={kind:'deflector', side};
      World.add(world, defl);
      const segs=[];
      for(let y=pipeBottom;y>pipeTop;y-=28){ const seg=Bodies.rectangle(x,y,pipeW,24,{isStatic:true,isSensor:true}); seg.plugin={kind:'lift',side,x,force:0.006}; World.add(world,seg); segs.push(seg);} 
      return {x,segs,intake,wallL,wallR,gapBottom,defl};
    }
    const leftPipe=makePipe(SIDE.LEFT), rightPipe=makePipe(SIDE.RIGHT);

    // Mirrored pachinko pin fields near each pipe (wider & farther from center)
    function makePins(side){
      const pins=[]; const rotors=[];
      const rows=10; // more rows
      const spacingX=Math.max(AMMO_R_BASE*4.2, W*0.022), spacingY=Math.max(AMMO_R_BASE*3.6, H*0.028);
      const startY=pipeTop+40;
      const mid = side===SIDE.LEFT? W*0.18 : W*0.82; const width = W*0.22; // farther from center
      for(let r=0;r<rows;r++){
        // every 3rd row is a spinner row
        if((r+1)%3===0){
          const cols=Math.max(3, Math.floor(width/(spacingX*1.5)));
          const rotR=Math.max(AMMO_R_BASE*1.6, 10);
          const sides = r%2?3:4;
          for(let c=0;c<cols;c++){
            const x = mid - width/2 + (c+0.5)*(width/cols);
            const y = startY + r*spacingY;
            const rotor=Bodies.polygon(x,y,sides,rotR,{frictionAir:0.02,restitution:0.2});
            rotor.plugin={kind:'rotor'};
            const pin=Constraint.create({pointA:{x,y},bodyB:rotor,length:0,stiffness:1});
            World.add(world,[rotor,pin]);
            Body.setAngularVelocity(rotor,(Math.random()-0.5)*1.2);
            rotors.push(rotor);
          }
        } else {
          const cols=Math.max(6, Math.floor(width/spacingX));
          const offset=(r%2?0.5:0)*spacingX;
          const pinR=Math.max(AMMO_R_BASE*0.7,3);
          for(let c=0;c<cols;c++){
            const x = mid - width/2 + c*spacingX + offset;
            const y = startY + r*spacingY;
            const pin=Bodies.circle(x,y,pinR,{isStatic:true,restitution:0.9}); pin.plugin={kind:'pin'}; World.add(world,pin); pins.push(pin);
          }
        }
      }
      return {mid,width,pins,rotors};
    }
    const pinsL=makePins(SIDE.LEFT), pinsR=makePins(SIDE.RIGHT);

    // Containers — 2 rows × 3 cols, narrower and spread to match pins
    function makeContainers(side, pinInfo){
      const mid = pinInfo.mid; const width = pinInfo.width;
      const cw = Math.max(56, W*0.035), ch=Math.max(28,H*0.038);
      const xCols = [mid - width*0.36, mid, mid + width*0.36];
      const yRows = [H*0.70, H*0.78];
      const mk=(x,y,label,accept,cap)=>{ const b=Bodies.rectangle(x,y,cw,ch,{isStatic:true,isSensor:true}); b.plugin={kind:'container',accept,label,side}; World.add(world,b); return {body:b,label,accept,fill:0,cap,pulse:0}; };
      return {
        cannon: mk(xCols[0], yRows[0], 'CANNON',['basic','heavy','volatile'], 18+rng.int(0,6)),
        laser:  mk(xCols[1], yRows[0], 'LASER', ['basic','emp'],          14+rng.int(0,6)),
        missile:mk(xCols[2], yRows[0], 'MISSILE',['heavy','volatile'],     12+rng.int(0,6)),
        mortar: mk(xCols[0], yRows[1], 'MORTAR',['basic','heavy'],         16+rng.int(0,6)),
        shield: mk(xCols[1], yRows[1], 'SHIELD',['emp','shield'],          12+rng.int(0,6)),
        repair: mk(xCols[2], yRows[1], 'REPAIR',['repair'],                10+rng.int(0,6))
      };
    }
    left = {side:SIDE.LEFT, color:COLORS.left,  bins:makeContainers(SIDE.LEFT,pinsL)};
    right= {side:SIDE.RIGHT,color:COLORS.right, bins:makeContainers(SIDE.RIGHT,pinsR)};

    // Determine core size/position to avoid bin overlap and stay near midline
    function calcCore(side){
      const baseR = Math.min(W,H)*0.15; const gapMid = Math.max(110,W*0.11); const clearance=18;
      if(side===SIDE.LEFT){
        const maxX = Math.max(...Object.values(left.bins).map(b=>b.body.bounds.max.x));
        let cx = Math.min(W/2 - gapMid, W*0.44);
        let R = Math.min(baseR, cx - (maxX + clearance));
        R = Math.max(Math.min(baseR, Math.min(W,H)*0.12), R);
        const cy = H*0.52; return {cx,cy,R,color:COLORS.left,side};
      } else {
        const minX = Math.min(...Object.values(right.bins).map(b=>b.body.bounds.min.x));
        let cx = Math.max(W/2 + gapMid, W*0.56);
        let R = Math.min(baseR, (minX - clearance) - cx);
        R = Math.max(Math.min(baseR, Math.min(W,H)*0.12), R);
        const cy = H*0.52; return {cx,cy,R,color:COLORS.right,side};
      }
    }
    const GAP_MID = Math.max(110, W*0.11); // stronger separation so cores never overlap
    const lc=calcCore(SIDE.LEFT), rc=calcCore(SIDE.RIGHT);

    function makeCore(cfg){ const segs=Array.from({length:12},()=>({hp:44+Math.floor(20*S.chaos)})); const centerHP=190+Math.floor(60*S.chaos); const centerBody=Bodies.circle(cfg.cx,cfg.cy,cfg.R*0.35,{isStatic:true,isSensor:true}); centerBody.plugin={kind:'coreCenter',side: cfg.side}; const ringBody=Bodies.circle(cfg.cx,cfg.cy,cfg.R,{isStatic:true,isSensor:true}); ringBody.plugin={kind:'coreRing',side: cfg.side}; World.add(world,[centerBody,ringBody]); return {center:{x:cfg.cx,y:cfg.cy},radius:cfg.R,segs,segHPmax:segs[0].hp,centerHP:centerHP,centerHPmax:centerHP,centerBody,ringBody,shield:0,rot:0,rotSpeed:(rng.next()*0.002+0.001)*(rng.next()<0.5?-1:1), color: cfg.color}; }
    coreL=makeCore(lc); coreR=makeCore(rc);

    // Weapons near midline (stay clear of pipes)
    function makeWeapons(side){
      const midTopY=H*0.12; // a touch lower to avoid header overlap
      const gap = Math.max(110, W*0.11);
      const topX = side===SIDE.LEFT? Math.min(W*0.47, W/2 - gap*0.6) : Math.max(W*0.53, W/2 + gap*0.6);
      const spread=Math.max(32,W*0.03);
      const bottomY=H*0.90;
      const bottomX = side===SIDE.LEFT? Math.min(W*0.48, W/2 - gap*0.7) : Math.max(W*0.52, W/2 + gap*0.7);
      const color = side===SIDE.LEFT? COLORS.left: COLORS.right;
      const top=(dx)=>({pos:{x:topX+dx,y:midTopY},color});
      const bottom=()=>({pos:{x:bottomX,y:bottomY},color});
      return { cannon:top(-spread), laser:top(0), missile:top(+spread), mortar:bottom() };
    }
    left.weapons = makeWeapons(SIDE.LEFT); right.weapons=makeWeapons(SIDE.RIGHT);

    // small sliders under each pin field to keep motion
    const paddles=[]; function addPaddle(x,y,amp,spd,dir){ const p=Bodies.rectangle(x,y,80,8,{isStatic:true,isSensor:true}); p.plugin={kind:'paddle',t:rng.next()*6,amp,spd,dir}; World.add(world,p); paddles.push(p);} 
    for(let i=0;i<4;i++){ const off=i*26; addPaddle(pinsL.mid, H*0.62+off, 40, 1.4+rng.next(), (i%2?1:-1)); addPaddle(pinsR.mid, H*0.62+off, 40, 1.4+rng.next(), (i%2?-1:1)); }

    // stats
    stats={leftAmmo:0,rightAmmo:0}; spawnAcc=0; ended=false; drawables=[];

    // collisions
    Events.on(engine,'collisionStart',e=>{ for(const p of e.pairs){ const A=p.bodyA,B=p.bodyB; const a=A.plugin||{}, b=B.plugin||{}; if(a.kind==='ammo'&&b.kind==='container') depositAmmo(A,B); else if(b.kind==='ammo'&&a.kind==='container') depositAmmo(B,A); if(a.kind==='projectile'&&(b.kind==='coreRing'||b.kind==='coreCenter')) hitCore(A,B); else if(b.kind==='projectile'&&(a.kind==='coreRing'||a.kind==='coreCenter')) hitCore(B,A);} });

    // beforeUpdate forces
    Events.on(engine,'beforeUpdate',()=>{
      const dt=(engine.timing.lastDelta||16)/1000;
      // conveyors push OUT toward edge pipes
      Composite.allBodies(world).forEach(b=>{ if(!b.plugin||b.plugin.kind!=='ammo') return; const y=b.position.y; if(y>H*0.915){ const dir= (b.position.x < W/2)? -1 : +1; Body.applyForce(b,b.position,{x: dir*0.002*b.mass, y: -0.001*b.mass}); }});
      // intake + lift
      Composite.allBodies(world).forEach(b=>{ if(!b.plugin||b.plugin.kind!=='ammo') return; [leftPipe,rightPipe].forEach(P=>{ const m=P.intake.bounds; if(b.position.x>m.min.x && b.position.x<m.max.x && b.position.y>m.min.y && b.position.y<m.max.y){ const toward = {x:P.x - b.position.x, y:(pipeBottom-60) - b.position.y}; const d = Math.hypot(toward.x,toward.y)||1; Body.applyForce(b,b.position,{x:(toward.x/d)*0.004*b.mass, y:(toward.y/d)*0.004*b.mass}); } if (b.position.x>P.x-24 && b.position.x<P.x+24 && b.position.y>pipeTop && b.position.y<pipeBottom){ Body.applyForce(b,b.position,{x:0,y:-0.006*b.mass}); } }); });
      // paddles
      paddles.forEach(p=>{ p.plugin.t+=dt*p.plugin.spd; const phase=Math.sin(p.plugin.t); const nx=p.position.x + phase*p.plugin.amp*p.plugin.dir; Body.setPosition(p,{x:nx,y:p.position.y}); const region=Query.region(Composite.allBodies(world),p.bounds); for(const body of region){ if(body.plugin&&body.plugin.kind==='ammo'){ Body.applyForce(body,body.position,{x: (phase*0.0022)*body.mass, y:-0.002*body.mass}); } } });
      // bins -> actions
      [left,right].forEach(SIDEOBJ=>{ const B=SIDEOBJ.bins; const WPN=SIDEOBJ.weapons; if(B.cannon.fill>=B.cannon.cap){B.cannon.fill=0; fireCannon(SIDEOBJ.side,WPN.cannon,18);} if(B.laser.fill>=B.laser.cap){B.laser.fill=0; fireLaser(SIDEOBJ.side,WPN.laser);} if(B.missile.fill>=B.missile.cap){B.missile.fill=0; fireMissiles(SIDEOBJ.side,WPN.missile,5);} if(B.mortar.fill>=B.mortar.cap){B.mortar.fill=0; fireMortar(SIDEOBJ.side,WPN.mortar);} if(B.shield && B.shield.fill>=B.shield.cap){B.shield.fill=0; (SIDEOBJ.side===SIDE.LEFT?coreL:coreR).shield=Math.max((SIDEOBJ.side===SIDE.LEFT?coreL:coreR).shield,2.5);} if(B.repair && B.repair.fill>=B.repair.cap){B.repair.fill=0; repairCore(SIDEOBJ.side===SIDE.LEFT?coreL:coreR,3);} });
      // soft-target spawning
      spawnAcc += engine.timing.lastDelta||16.6; const target=S.maxAmmo, minT=target*0.75, softMax=target*1.25; const msPer=1000/S.spawnRate; while(spawnAcc>msPer){ spawnAcc-=msPer; for(const side of [SIDE.LEFT,SIDE.RIGHT]){ const cnt = side===SIDE.LEFT?stats.leftAmmo:stats.rightAmmo; if(cnt>=softMax) continue; if(cnt<minT*0.85) {spawnAmmo(side); spawnAmmo(side);} else if(cnt<minT) spawnAmmo(side); else if(cnt<target){ if(Math.random()<0.9) spawnAmmo(side);} else { if(Math.random()<0.25) spawnAmmo(side);} } }
      [coreL,coreR].forEach(c=>{ if(c.shield>0)c.shield-=dt; if(c.shield<0)c.shield=0; c.rot+=c.rotSpeed;});
    });

    // render loop
    requestAnimationFrame(function draw(){ const W=canvas.clientWidth,H=canvas.clientHeight; AMMO_R_BASE = Math.max(3, Math.min(7, Math.round(Math.min(W,H)*0.006))); ctx.clearRect(0,0,W,H);
      // center line
      ctx.setLineDash([6,6]); ctx.strokeStyle='#20336e'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke(); ctx.setLineDash([]);
      // conveyors (outward)
      drawConveyor(W*0.25,convY,convW,18,COLORS.left,-1); drawConveyor(W*0.75,convY,convW,18,COLORS.right,+1);
      // pipe walls
      drawPipe(leftPipe); drawPipe(rightPipe);
      // pins
      ctx.fillStyle='#2b3a78'; Composite.allBodies(world).forEach(b=>{ if(b.plugin&&b.plugin.kind==='pin'){ ctx.beginPath(); ctx.arc(b.position.x,b.position.y,b.circleRadius,0,Math.PI*2); ctx.fill(); }});
      // rotors
      ctx.strokeStyle='#2b3a78'; ctx.lineWidth=2; Composite.allBodies(world).forEach(b=>{ if(b.plugin&&b.plugin.kind==='rotor'){ ctx.beginPath(); const v=b.vertices; ctx.moveTo(v[0].x,v[0].y); for(let i=1;i<v.length;i++){ ctx.lineTo(v[i].x,v[i].y);} ctx.closePath(); ctx.stroke(); }});
      // paddles
      ctx.strokeStyle='#2b3a78'; ctx.lineWidth=8; paddles.forEach(p=>{ ctx.beginPath(); ctx.moveTo(p.bounds.min.x,p.position.y); ctx.lineTo(p.bounds.max.x,p.position.y); ctx.stroke();});
      // bins
      drawBins(left); drawBins(right);
      // weapons
      drawWeapons(left); drawWeapons(right);
      // bodies
      drawBodies();
      // cores
      drawCore(coreL); drawCore(coreR);
      // beams
      drawables = drawables.filter(d=>{ d.t -= 16; if(d.kind==='beam'){ ctx.save(); ctx.globalAlpha = Math.max(0, d.t/d.T); ctx.strokeStyle=d.color; ctx.lineWidth=5; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke(); ctx.restore(); } return d.t>0; });
      // HUD
      leftHP.textContent=`${coreL.centerHP}|Σ${coreL.segs.reduce((s,v)=>s+Math.max(0,v.hp),0)}`; rightHP.textContent=`${coreR.centerHP}|Σ${coreR.segs.reduce((s,v)=>s+Math.max(0,v.hp),0)}`;
      requestAnimationFrame(draw);
    });

    // helpers: drawing
    function drawPipe(P){ const Wc=canvas.clientWidth, Hc=canvas.clientHeight; const top=Hc*0.10, bottom=Hc*0.925; const x=P.x; const w=Math.max(36,Wc*0.036); const gap=Math.max(60,Hc*0.08); ctx.fillStyle='#0e1730'; ctx.fillRect(x-w/2-12, top-10, 12, (bottom-top-gap)+20); ctx.fillRect(x+w/2, top-10, 12, (bottom-top-gap)+20); ctx.fillStyle='rgba(0,255,213,0.10)'; const m=P.intake.bounds; ctx.fillRect(m.min.x, m.min.y, m.max.x-m.min.x, m.max.y-m.min.y); }
    function drawConveyor(x,y,w,h,color,dir){ ctx.save(); ctx.translate(x-w/2,y-h/2); ctx.fillStyle='rgba(32,52,120,.2)'; ctx.fillRect(0,0,w,h); ctx.strokeStyle=color; ctx.strokeRect(0,0,w,h); const step=22; for(let a=10;a<w-10;a+=step){ ctx.beginPath(); const ax=x-w/2+a; ctx.moveTo(ax, y-6); ctx.lineTo(ax+dir*8,y); ctx.lineTo(ax, y+6); ctx.stroke(); } ctx.restore(); }
    function drawBins(SIDEOBJ){ const color=SIDEOBJ.color; Object.values(SIDEOBJ.bins).forEach(bin=>{ const {min,max}=bin.body.bounds; const x=min.x,y=min.y,w=max.x-min.x,h=max.y-min.y; ctx.fillStyle='#0a1227'; ctx.fillRect(x,y,w,h); ctx.strokeStyle=color; ctx.strokeRect(x,y,w,h); ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+w,y); ctx.lineWidth=3; ctx.strokeStyle='#9fc5ff'; ctx.stroke(); ctx.lineWidth=1; const m=bin.fill/bin.cap; ctx.fillStyle=color; ctx.globalAlpha=.25+.6*Math.min(1,m); ctx.fillRect(x+2,y+h-4-(h-6)*Math.min(1,m),w-4,(h-6)*Math.min(1,m)); ctx.globalAlpha=1; ctx.fillStyle='#cfe6ff'; ctx.font='10px Verdana'; ctx.fillText(bin.label,x+4,y+h+12); }); }
    function drawWeapons(S){ const w=S.weapons; const color=S.color; function icon(pt,shape){ ctx.save(); ctx.translate(pt.x,pt.y); ctx.strokeStyle=color; ctx.lineWidth=2; if(shape==='cannon'){ ctx.strokeRect(-10,-6,20,12); ctx.beginPath(); ctx.moveTo(10,-2); ctx.lineTo(22,0); ctx.lineTo(10,2); ctx.stroke(); } if(shape==='laser'){ ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke(); } if(shape==='missile'){ ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(8,0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(8,0); ctx.lineTo(14,-4); ctx.lineTo(14,4); ctx.closePath(); ctx.stroke(); } if(shape==='mortar'){ ctx.beginPath(); ctx.arc(0,0,10,Math.PI*0.8,Math.PI*1.9); ctx.stroke(); } ctx.restore(); } icon(w.cannon.pos,'cannon'); icon(w.laser.pos,'laser'); icon(w.missile.pos,'missile'); icon(w.mortar.pos,'mortar'); }
    function drawBodies(){ const bodies=Composite.allBodies(world); bodies.forEach(b=>{ if(!b.plugin) return; if(b.plugin.kind==='ammo'){ const t=b.plugin.type; let col='#b6ff00'; if(t==='heavy')col='#ffca1a'; else if(t==='volatile')col='#ff3d3d'; else if(t==='sticky')col='#b86bff'; else if(t==='emp')col='#00ffd5'; else if(t==='repair')col='#6bffb8'; else if(t==='shield')col='#9fc5ff'; ctx.beginPath(); ctx.arc(b.position.x,b.position.y,b.circleRadius||6,0,Math.PI*2); ctx.fillStyle=col; ctx.globalAlpha=.9; ctx.fill(); ctx.globalAlpha=1; ctx.strokeStyle='#0a1227'; ctx.lineWidth=1; ctx.stroke(); } else if(b.plugin.kind==='projectile'){ ctx.beginPath(); ctx.arc(b.position.x,b.position.y,3,0,Math.PI*2); ctx.fillStyle=COLORS.accent; ctx.fill(); } }); }
  }

  // ===== actions =====
  function depositAmmo(ammo, container){ const accept=(container.plugin&&container.plugin.accept)||[]; if(accept.includes(ammo.plugin.type)){ World.remove(world,ammo); (ammo.plugin.side===SIDE.LEFT? stats.leftAmmo--: stats.rightAmmo--); const sideObj = container.plugin.side===SIDE.LEFT? left: right; const which = Object.values(sideObj.bins).find(b=>b.body.id===container.id); if(which){ which.fill++; which.pulse=1; } } }
  function repairCore(core, n){ for(let k=0;k<n;k++){ let idx=0,min=1e9; for(let i=0;i<core.segs.length;i++){ const s=core.segs[i]; if(s.hp<min){min=s.hp; idx=i;}} core.segs[idx].hp=Math.min(core.segHPmax, core.segs[idx].hp + 10);} if(Math.random()<0.25) core.centerHP=Math.min(core.centerHPmax, core.centerHP+6); }
  function hitCore(proj, coreBody){ const sideHit=coreBody.plugin.side; const core= sideHit===SIDE.LEFT? coreL: coreR; const dmgBase=proj.plugin.dmg||0; const dmg = core.shield>0? Math.max(1,Math.floor(dmgBase*0.35)): dmgBase; if(coreBody.plugin.kind==='coreCenter'){ core.centerHP -= dmg;} else { const v=Vector.sub(proj.position, core.center); const ang=Math.atan2(v.y,v.x)-core.rot; const sp=segSplitFromAngle(core,ang); const d0=Math.round(dmg*sp.w0), d1=dmg-d0; core.segs[sp.i0].hp=Math.max(0, core.segs[sp.i0].hp-d0); core.segs[sp.i1].hp=Math.max(0, core.segs[sp.i1].hp-d1); if(Math.random()<0.08) core.centerHP--; } World.remove(world,proj); if(core.centerHP<=0){ endMatch(sideHit===SIDE.LEFT? 'RIGHT WINS':'LEFT WINS'); } }

  function fireCannon(fromSide,w,burst){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; const dir=Vector.normalise({x:target.x-w.pos.x,y:target.y-w.pos.y}); const speed=22+Number(chaosInp.value)*10; for(let i=0;i<burst;i++){ setTimeout(()=>{ const b=Bodies.circle(w.pos.x,w.pos.y,4,{restitution:0.2,friction:0.01,density:0.002}); b.plugin={kind:'projectile',side:fromSide,dmg:8+Math.floor(Number(chaosInp.value)*6)}; World.add(world,b); Body.setVelocity(b,{x:dir.x*speed+(Math.random()-0.5)*4,y:dir.y*speed+(Math.random()-0.5)*4}); drawables.push({kind:'beam',a:{x:w.pos.x,y:w.pos.y},b:{x:w.pos.x+dir.x*24,y:w.pos.y+dir.y*24},color: fromSide===SIDE.LEFT?COLORS.left:COLORS.right,T:120,t:120}); },i*40);} }
  function fireLaser(fromSide,w){ const dps=40; const T=600; const color=fromSide===SIDE.LEFT?COLORS.left:COLORS.right; const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; drawables.push({kind:'beam',a:w.pos,b:target,color,T,t:T}); const core = fromSide===SIDE.LEFT? coreR:coreL; let t=0; const id=setInterval(()=>{ const dt=50; t+=dt; if(core.shield>0){ core.centerHP -= Math.max(1,Math.floor(dps*0.2*dt/1000)); } else { core.centerHP -= Math.floor(dps*dt/1000); } if(t>=T){ clearInterval(id);} if(core.centerHP<=0){ clearInterval(id); endMatch(fromSide===SIDE.LEFT? 'LEFT WINS':'RIGHT WINS'); } },50); }
  function fireMissiles(fromSide,w,count){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; for(let i=0;i<count;i++){ setTimeout(()=>{ const m=Bodies.circle(w.pos.x,w.pos.y,5,{density:0.003,frictionAir:0.02}); m.plugin={kind:'projectile',type:'missile',side:fromSide,dmg:14}; World.add(world,m); Body.setVelocity(m,{x:(fromSide===SIDE.LEFT?1:-1)*6+(Math.random()-0.5)*2,y:2}); const id=setInterval(()=>{ if(!world||!m.position) {clearInterval(id);return;} const v={x:target.x-m.position.x,y:target.y-m.position.y}; const d=Math.hypot(v.x,v.y)||1; Body.applyForce(m,m.position,{x:(v.x/d)*0.0008*m.mass,y:(v.y/d)*0.0008*m.mass}); },30); },i*100);} }
  function fireMortar(fromSide,w){ const target = fromSide===SIDE.LEFT? coreR.center:coreL.center; for(let i=0;i<2;i++){ setTimeout(()=>{ const shell=Bodies.circle(w.pos.x,w.pos.y,6,{density:0.004,restitution:0.2}); shell.plugin={kind:'projectile',type:'mortar',side:fromSide,dmg:22}; World.add(world,shell); const vx=(target.x-w.pos.x)/40 + (Math.random()-0.5)*2; const vy=-16 + (Math.random()-0.5)*2; Body.setVelocity(shell,{x:vx,y:vy}); },i*200);} }

  // ===== Spawning
  function spawnAmmo(side){ const W=canvas.clientWidth,H=canvas.clientHeight; const x = side===SIDE.LEFT? 30+Math.random()*40 : W-30-Math.random()*40; const y=H*0.92+Math.random()*10; const AMMO=['basic','heavy','volatile','sticky','emp','repair','shield']; const pool=Math.random()<0.7? ['basic','heavy'] : AMMO; const t=pool[(Math.random()*pool.length)|0]; let r = (t==='heavy'? AMMO_R_BASE+2 : AMMO_R_BASE); r=Math.max(3,Math.min(10,r)); const b=Bodies.circle(x,y,r,{restitution:0.6,friction:0.02,density:0.0015}); b.plugin={kind:'ammo',side,type:t}; World.add(world,b); Body.setVelocity(b,{x: side===SIDE.LEFT? -1:+1, y:-1}); if(side===SIDE.LEFT) stats.leftAmmo++; else stats.rightAmmo++; }

  // ===== End / stop / UI =====
  function endMatch(msg){ if(ended) return; ended=true; stateEl.textContent=msg; setTimeout(()=>{ if(loopEl.value==='1' && msg!=='Canceled'){ start(lastSettings); } else { panel.style.display='flex'; stopBtn.style.display='none'; hud.style.display='none'; isRunning=false; } },2000); }
  function stop(){ if(runner){Runner.stop(runner); runner=null;} if(engine){ const all=Composite.allBodies(engine.world); for(const b of all) World.remove(engine.world,b); engine=null; world=null;} stateEl.textContent='Idle'; }

  // ===== Drawing core =====
  function drawCore(core){ const x=core.center.x,y=core.center.y,R=core.radius; ctx.lineWidth=8; ctx.strokeStyle=core.color; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; const n=core.segs.length, step=Math.PI*2/n; for(let i=0;i<n;i++){ const seg=core.segs[i]; const t=seg.hp/core.segHPmax; const a0=i*step+core.rot-0.04, a1=(i+1)*step+core.rot+0.04; ctx.beginPath(); ctx.moveTo(x,y); ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath(); ctx.fillStyle= i%2? '#0e1730':'#0b1227'; ctx.fill(); if(t>0){ ctx.save(); ctx.globalAlpha=.15 + .75*t; ctx.fillStyle=core.color; ctx.beginPath(); ctx.moveTo(x,y); ctx.arc(x,y,R*0.86,a0,a1); ctx.closePath(); ctx.fill(); ctx.restore(); } else { ctx.save(); ctx.globalAlpha=.25; ctx.strokeStyle='#234'; for(let k=0;k<5;k++){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a0+k*.2)*R*0.86, y+Math.sin(a0+k*.2)*R*0.86); ctx.stroke(); } ctx.restore(); } }
    ctx.fillStyle='#091125'; ctx.beginPath(); ctx.arc(x,y,R*0.34,0,Math.PI*2); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle=core.color; ctx.stroke(); if(core.shield>0){ const p=Math.min(1,core.shield/2.5); ctx.save(); ctx.globalAlpha=.12+.2*p; ctx.strokeStyle='#00ffd5'; ctx.lineWidth=16; ctx.beginPath(); ctx.arc(x,y,R*1.05,0,Math.PI*2); ctx.stroke(); ctx.restore(); } if(core.centerHP<=0){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='bold 22px Verdana'; ctx.fillStyle='#0b1227'; ctx.fillText('DEAD', x+2, y-R*0.34-10+2); ctx.fillStyle='#ff3d3d'; ctx.shadowColor='#ff3d3d'; ctx.shadowBlur=12; ctx.fillText('DEAD', x, y-R*0.34-10); ctx.restore(); } }

  // ===== UI hooks =====
  startBtn.onclick=()=> start(); demoBtn.onclick=()=>{ seedEl.value=''; chaosInp.value=(Math.random()*0.9+0.1).toFixed(2); chaosValEl.textContent=chaosInp.value; spawnRateEl.value= 18+Math.floor(Math.random()*18); maxAmmoEl.value= 220+Math.floor(Math.random()*160); start(); };
  stopBtn.onclick=()=> endMatch('Canceled');
})();
</script>
</body>
</html>
